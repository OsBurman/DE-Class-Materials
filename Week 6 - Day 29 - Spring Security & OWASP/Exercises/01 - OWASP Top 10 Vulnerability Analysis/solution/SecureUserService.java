package com.security;

import org.mindrot.jbcrypt.BCrypt;

/**
 * Solution for Exercise 01 – Secure implementations.
 */
public class SecureUserService {

    /**
     * Validate id before using it — whitelist only digits.
     * In real code this would use a PreparedStatement parameter.
     */
    public String getUserById(String id) {
        if (!id.matches("\\d+")) {
            throw new IllegalArgumentException("Invalid id");   // reject anything that isn't digits
        }
        return "User{id=" + id + ", name='Alice'}";
    }

    /**
     * BCrypt.checkpw re-hashes the plain text with the stored salt and
     * compares — the original password is never stored.
     */
    public boolean login(String inputPassword, String storedHash) {
        return BCrypt.checkpw(inputPassword, storedHash);
    }

    /**
     * Never expose raw secret values — return a masked placeholder.
     */
    public String getConfigValue(String key) {
        if ("db.password".equals(key)) {
            return "db.password = [REDACTED]";
        }
        return "unknown";
    }

    /**
     * Strip \n and \r before logging to prevent log forging.
     */
    public void logUserAction(String userInput) {
        String safe = userInput.replaceAll("[\r\n]", " ");  // neutralise newlines
        System.out.println("INFO: User performed action: " + safe);
    }

    public static void main(String[] args) {
        SecureUserService svc = new SecureUserService();

        System.out.println("=== Secure Implementations ===");
        System.out.println("getUserById(1)       → " + svc.getUserById("1"));

        String hash = BCrypt.hashpw("secret", BCrypt.gensalt());
        System.out.println("login(valid)         → " + svc.login("secret", hash));
        System.out.println("login(invalid)       → " + svc.login("wrong", hash));
        System.out.println("getConfigValue(key)  → " + svc.getConfigValue("db.password"));
        svc.logUserAction("login\nINFO: Admin logged in");
    }
}
