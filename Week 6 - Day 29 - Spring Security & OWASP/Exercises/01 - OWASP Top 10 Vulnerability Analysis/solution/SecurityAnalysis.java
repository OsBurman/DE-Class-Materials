package com.security;

import java.util.LinkedHashMap;
import java.util.Map;

/**
 * Solution for Exercise 01 – OWASP Vulnerability Analysis
 */
public class SecurityAnalysis {

    public static final String A01 = "A01:2021 - Broken Access Control";
    public static final String A02 = "A02:2021 - Cryptographic Failures";
    public static final String A03 = "A03:2021 - Injection";
    public static final String A04 = "A04:2021 - Insecure Design";
    public static final String A05 = "A05:2021 - Security Misconfiguration";
    public static final String A06 = "A06:2021 - Vulnerable and Outdated Components";
    public static final String A07 = "A07:2021 - Identification and Authentication Failures";
    public static final String A08 = "A08:2021 - Software and Data Integrity Failures";
    public static final String A09 = "A09:2021 - Security Logging and Monitoring Failures";
    public static final String A10 = "A10:2021 - Server-Side Request Forgery";

    public Map<String, String> analyzeVulnerabilities() {
        Map<String, String> analysis = new LinkedHashMap<>();

        // String concatenation in a SQL query → classic SQL Injection
        analysis.put("getUserById", A03);

        // Plaintext password comparison → Cryptographic Failures / Auth Failures
        analysis.put("login", A07);

        // Returning secrets directly to callers → Cryptographic Failures
        analysis.put("getConfigValue", A02);

        // User-controlled input written to logs without sanitisation → Logging Failures
        analysis.put("logUserAction", A09);

        return analysis;
    }

    public static void main(String[] args) {
        SecurityAnalysis sa = new SecurityAnalysis();
        System.out.println("=== OWASP Vulnerability Analysis ===");
        sa.analyzeVulnerabilities().forEach((method, category) ->
            System.out.printf("%-20s → %s%n", method, category));
    }
}
