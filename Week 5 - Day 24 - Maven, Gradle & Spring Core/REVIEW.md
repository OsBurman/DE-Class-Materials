# Day 24 Review — Maven, Gradle & Spring Core

---

## 1. Build Tools Overview

Build tools automate the repetitive tasks in software development:
- **Dependency management** — download and manage third-party libraries
- **Compilation** — compile source code to bytecode
- **Testing** — run automated tests and report results
- **Packaging** — bundle the application into a deployable artifact (JAR/WAR)

The two dominant build tools in Java:
| | Maven | Gradle |
|---|---|---|
| Config format | XML (`pom.xml`) | Groovy/Kotlin DSL (`build.gradle`) |
| Released | 2004 | 2012 |
| Philosophy | Convention over configuration | Flexible, programmable |
| Speed | Slower | Faster (incremental builds, caching) |

---

## 2. Maven Directory Structure

```
my-project/
├── pom.xml
└── src/
    ├── main/
    │   ├── java/          ← production source code
    │   └── resources/     ← application.properties, XML configs
    └── test/
        ├── java/          ← test source code
        └── resources/     ← test configs, test data
target/                    ← generated by Maven (never commit to git)
```

Maven enforces this structure by convention. If your code is in the right place, Maven compiles it without any configuration.

---

## 3. pom.xml Reference

```xml
<?xml version="1.0" encoding="UTF-8"?>
<project xmlns="http://maven.apache.org/POM/4.0.0">
    <modelVersion>4.0.0</modelVersion>

    <!-- Spring Boot Parent — imports dependency versions via BOM -->
    <parent>
        <groupId>org.springframework.boot</groupId>
        <artifactId>spring-boot-starter-parent</artifactId>
        <version>3.2.0</version>
    </parent>

    <!-- GAV Coordinates — uniquely identify this artifact -->
    <groupId>com.bookstore</groupId>
    <artifactId>bookstore</artifactId>
    <version>1.0.0-SNAPSHOT</version>
    <packaging>jar</packaging>

    <properties>
        <java.version>17</java.version>
    </properties>

    <dependencies>
        <!-- compile scope (default) — included in JAR -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-web</artifactId>
        </dependency>

        <!-- optional — not included in dependents' classpaths -->
        <dependency>
            <groupId>org.projectlombok</groupId>
            <artifactId>lombok</artifactId>
            <optional>true</optional>
        </dependency>

        <!-- test scope — only for compiling and running tests -->
        <dependency>
            <groupId>org.springframework.boot</groupId>
            <artifactId>spring-boot-starter-test</artifactId>
            <scope>test</scope>
        </dependency>
    </dependencies>

    <build>
        <plugins>
            <!-- creates executable "fat JAR" with embedded server -->
            <plugin>
                <groupId>org.springframework.boot</groupId>
                <artifactId>spring-boot-maven-plugin</artifactId>
                <configuration>
                    <excludes>
                        <exclude>
                            <groupId>org.projectlombok</groupId>
                            <artifactId>lombok</artifactId>
                        </exclude>
                    </excludes>
                </configuration>
            </plugin>
        </plugins>
    </build>
</project>
```

### GAV Coordinates
- **groupId** — reverse domain name of the organization (`com.bookstore`)
- **artifactId** — the project name (`bookstore`)
- **version** — `1.0.0-SNAPSHOT` or `1.0.0` (RELEASE)
  - `SNAPSHOT` = in-development, may change
  - No suffix = stable release, immutable in Maven Central

---

## 4. Maven Lifecycle Phases

The **default lifecycle** has 7 key phases that run in order:

| Phase | What Happens |
|---|---|
| `validate` | Checks the pom.xml is correct and complete |
| `compile` | Compiles `src/main/java` → `target/classes/` |
| `test` | Runs unit tests in `src/test/java` |
| `package` | Bundles classes into a JAR → `target/` |
| `verify` | Runs integration tests, checks quality |
| `install` | Copies JAR to local `~/.m2` repository |
| `deploy` | Uploads JAR to remote repository (Nexus/Artifactory) |

Running a phase also runs all preceding phases:
- `mvn package` runs validate → compile → test → package

### Key Commands
```bash
mvn clean package          # delete target/, then compile/test/package
mvn clean install          # also install to local Maven cache
mvn clean package -DskipTests  # skip tests (use sparingly)
mvn spring-boot:run        # run the Spring Boot app
mvn test                   # run tests only
mvn dependency:tree        # print full dependency tree
mvn javadoc:javadoc        # generate Javadoc HTML
```

---

## 5. Dependency Scopes (Maven)

| Scope | Available When | In JAR | Example Use |
|---|---|---|---|
| `compile` | compile + runtime + test | ✅ | Spring Boot starters |
| `test` | test only | ❌ | JUnit, Mockito |
| `provided` | compile + test | ❌ | Servlet API (container provides it) |
| `runtime` | runtime + test | ✅ | JDBC drivers |
| `optional` | compile only | ❌ | Lombok (annotation processor) |

### Conflict Resolution
- Maven uses **nearest-wins**: the dependency closest to your project in the dependency tree wins
- Use `<dependencyManagement>` to lock versions without adding dependencies directly
- The Spring Boot parent already does this for all Spring-managed libraries

---

## 6. Maven Plugin Reference

| Plugin | Default Phase | Purpose |
|---|---|---|
| `maven-compiler-plugin` | compile | Compiles Java source code |
| `maven-surefire-plugin` | test | Runs unit tests |
| `maven-failsafe-plugin` | verify | Runs integration tests |
| `spring-boot-maven-plugin` | package | Creates executable fat JAR |
| `maven-javadoc-plugin` | site | Generates Javadoc HTML |
| `spotbugs-maven-plugin` | verify | Static analysis for bugs |
| `maven-checkstyle-plugin` | verify | Enforces code style rules |
| `jacoco-maven-plugin` | verify | Measures test code coverage |

---

## 7. Gradle Build Scripts

### Groovy DSL — `build.gradle`
```groovy
plugins {
    id 'java'
    id 'org.springframework.boot' version '3.2.0'
    id 'io.spring.dependency-management' version '1.1.4'
}

group = 'com.bookstore'
version = '1.0.0-SNAPSHOT'

java {
    sourceCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    implementation 'org.springframework.boot:spring-boot-starter-web'
    compileOnly 'org.projectlombok:lombok'
    annotationProcessor 'org.projectlombok:lombok'
    testImplementation 'org.springframework.boot:spring-boot-starter-test'
}
```

### Kotlin DSL — `build.gradle.kts`
```kotlin
plugins {
    java
    id("org.springframework.boot") version "3.2.0"
    id("io.spring.dependency-management") version "1.1.4"
}

group = "com.bookstore"
version = "1.0.0-SNAPSHOT"

java {
    sourceCompatibility = JavaVersion.VERSION_17
}

repositories {
    mavenCentral()
}

dependencies {
    implementation("org.springframework.boot:spring-boot-starter-web")
    compileOnly("org.projectlombok:lombok")
    annotationProcessor("org.projectlombok:lombok")
    testImplementation("org.springframework.boot:spring-boot-starter-test")
}
```

> ⚠️ **Lombok in Gradle** requires BOTH `compileOnly` AND `annotationProcessor`. Forgetting `annotationProcessor` means Lombok annotations are silently ignored — no getters, no constructors generated.

---

## 8. Gradle Tasks Reference

```bash
./gradlew build            # compile, test, and create JAR
./gradlew test             # run tests only
./gradlew bootRun          # run the Spring Boot app
./gradlew clean            # delete build/ directory
./gradlew build -x test    # build, skipping tests
./gradlew dependencies     # print dependency tree
./gradlew tasks            # list all available tasks
```

> Always use `./gradlew` (the Gradle Wrapper) — never the system-installed `gradle`. The wrapper guarantees the correct Gradle version regardless of what is installed locally.

### Task Graph vs Maven Lifecycle
- Maven: fixed linear lifecycle (validate → compile → test → package → ...)
- Gradle: directed acyclic graph (DAG) — tasks declare their inputs and outputs; Gradle runs the minimum set of tasks needed

---

## 9. Gradle Dependency Configurations

| Configuration | Compile | Runtime | Consumers Get | Use For |
|---|---|---|---|---|
| `implementation` | ✅ | ✅ | ❌ | Standard dependencies (preferred) |
| `api` | ✅ | ✅ | ✅ | Expose to library consumers |
| `compileOnly` | ✅ | ❌ | ❌ | Annotation processors (Lombok) |
| `runtimeOnly` | ❌ | ✅ | ❌ | JDBC drivers, runtime implementations |
| `testImplementation` | test | test | ❌ | JUnit, Mockito |
| `annotationProcessor` | compile | ❌ | ❌ | Lombok, MapStruct, etc. |

**`implementation` vs `api`**: Use `implementation` for all application code. Only use `api` if you are building a library and intentionally exposing a dependency as part of your library's public API.

---

## 10. Maven vs Gradle Comparison

| Feature | Maven | Gradle |
|---|---|---|
| Config language | XML | Groovy or Kotlin DSL |
| Learning curve | Lower | Higher |
| Build speed | Slower | Faster (incremental, cache) |
| Flexibility | Convention-driven | Fully programmable |
| Plugin ecosystem | Very large | Large and growing |
| Multi-module support | Yes | Yes (superior) |
| IDE support | Excellent | Excellent |
| Industry adoption | Very high | High (dominant in Android) |

**When to choose Maven**: Team is Java-only, smaller projects, team familiar with XML, existing Maven ecosystem.

**When to choose Gradle**: Complex multi-module builds, Android development, need incremental build performance, prefer code-based config.

---

## 11. Java Naming Conventions

| Element | Convention | Example |
|---|---|---|
| Classes, Interfaces | UpperCamelCase | `BookService`, `BookRepository` |
| Methods, Variables | lowerCamelCase | `findById()`, `bookTitle` |
| Constants | UPPER_SNAKE_CASE | `MAX_RETRIES`, `DEFAULT_PORT` |
| Packages | lowercase only | `com.bookstore.service` |
| Enums | UpperCamelCase | `BookStatus` |
| Enum values | UPPER_SNAKE_CASE | `IN_STOCK`, `OUT_OF_STOCK` |

### Method Naming Patterns
- Boolean queries: `isActive()`, `hasPermission()`, `canEdit()`
- Queries: `findById()`, `getAll()`, `countByCategory()`
- Mutations: `save()`, `update()`, `deleteById()`
- Transformations: `toDto()`, `fromEntity()`, `convert()`

---

## 12. Package Structure

### Standard Spring Boot Layer Structure (Package by Layer)
```
com.bookstore
├── BookstoreApplication.java    ← main class at root package
├── controller/                  ← @RestController classes
├── service/                     ← @Service classes
├── repository/                  ← @Repository interfaces
├── model/                       ← domain entity classes
├── dto/                         ← Data Transfer Objects
├── exception/                   ← custom exceptions
└── config/                      ← @Configuration classes
```

> ⚠️ The main class **must** be in the root package (`com.bookstore`), not a sub-package. Spring Boot's `@ComponentScan` scans from the main class's package downward. Classes in packages above it are not found.

### Package by Feature (alternative for large apps)
```
com.bookstore
├── BookstoreApplication.java
├── book/
│   ├── BookController.java
│   ├── BookService.java
│   ├── BookRepository.java
│   └── Book.java
└── user/
    ├── UserController.java
    ├── UserService.java
    └── UserRepository.java
```

---

## 13. Code Comments Best Practices

**Comment the "why", not the "what":**

```java
// ❌ Bad — restates the code
// increment i by 1
i++;

// ❌ Bad — outdated comment (the code was changed, the comment wasn't)
// returns the user's name
public String getUserEmail() { ... }

// ✅ Good — explains a non-obvious decision
// Cache expires after 5 minutes to balance freshness with API rate limits
private static final int CACHE_TTL_SECONDS = 300;

// ✅ Good — explains a workaround
// ISBN-10 check digit calculation uses modulo 11; ISBN-13 uses modulo 10
// See: https://isbn-information.com/the-check-digit-for-the-isbn-13.html
```

**Good code is self-documenting through:**
- Meaningful class and method names
- Short, focused methods that do one thing
- Descriptive variable names instead of abbreviations

---

## 14. Javadoc Format Reference

```java
/**
 * Finds a book by its unique identifier.
 *
 * <p>Returns an empty Optional if no book exists with the given ID.
 * The ID must be a positive long value assigned by the database.
 *
 * @param id the unique identifier of the book; must be positive
 * @return an Optional containing the book if found, or empty if not found
 * @throws IllegalArgumentException if id is null or non-positive
 */
Optional<Book> findById(Long id);
```

### Javadoc Tags
| Tag | Purpose |
|---|---|
| `@param name description` | Documents a parameter |
| `@return description` | Documents the return value |
| `@throws ExceptionType description` | Documents a thrown exception |
| `@see ClassName#methodName` | Cross-reference to related code |
| `@since 1.2.0` | Version when this was added |
| `@deprecated description` | Marks as deprecated, explains replacement |

Generate HTML Javadoc: `mvn javadoc:javadoc` → output in `target/site/apidocs/`

---

## 15. Code Quality Tools

### Checkstyle
```xml
<!-- pom.xml -->
<plugin>
    <groupId>org.apache.maven.plugins</groupId>
    <artifactId>maven-checkstyle-plugin</artifactId>
    <version>3.3.1</version>
    <configuration>
        <configLocation>google_checks.xml</configLocation>
        <failsOnError>true</failsOnError>
    </configuration>
</plugin>
```
Checkstyle enforces **style** rules: naming conventions, brace placement, line length, import ordering.

### SpotBugs
```xml
<plugin>
    <groupId>com.github.spotbugs</groupId>
    <artifactId>spotbugs-maven-plugin</artifactId>
    <version>4.8.3.0</version>
</plugin>
```
SpotBugs detects **bug patterns**: null dereferences, resource leaks, synchronization issues, infinite loops.

### Running in CI
```bash
mvn clean verify   # runs Checkstyle + SpotBugs during the verify phase
```

---

## 16. Spring Framework Architecture

The Spring Framework consists of modules that can be used independently:

| Module | Purpose |
|---|---|
| **Spring Core** | IoC container, dependency injection — the foundation |
| **Spring Context** | ApplicationContext, component scanning, events |
| **Spring AOP** | Aspect-Oriented Programming — cross-cutting concerns |
| **Spring MVC** | Web framework, REST controllers |
| **Spring Data** | Repositories, JPA integration, query DSL |
| **Spring Security** | Authentication and authorization |
| **Spring Boot** | Auto-configuration, embedded servers, production tools |

Spring Boot is not separate from Spring — it's a layer on top of these modules that applies auto-configuration so you write less setup code.

---

## 17. Inversion of Control (IoC)

**Traditional control flow:**
```java
// BookService creates its own dependencies
public class BookService {
    private BookRepository repo = new BookRepositoryImpl();  // tightly coupled
    private NotificationService ns = new EmailNotificationService();
}
```

Problems: `BookService` is coupled to specific implementations. Testing requires real infrastructure. Changing implementations requires modifying `BookService`.

**IoC (control is inverted — Spring provides dependencies):**
```java
public class BookService {
    private final BookRepository repo;
    private final NotificationService notificationService;

    // BookService declares what it needs; Spring decides what to provide
    public BookService(BookRepository repo, NotificationService notificationService) {
        this.repo = repo;
        this.notificationService = notificationService;
    }
}
```

**The Hollywood Principle**: "Don't call us, we'll call you." Your classes don't fetch their dependencies — Spring calls your constructors and provides them.

---

## 18. Dependency Injection Types Comparison

| Type | Syntax | Recommended | Fields Can Be `final` | Testable Without Spring |
|---|---|---|---|---|
| Constructor | Parameter in constructor | ✅ Yes | ✅ Yes | ✅ Yes |
| Setter | `@Autowired` on setter | For optional deps | ❌ No | ⚠️ Partially |
| Field | `@Autowired` on field | ❌ No | ❌ No | ❌ No |

### Constructor Injection (Preferred)
```java
@Service
public class BookService {
    private final BookRepository bookRepository;
    private final NotificationService notificationService;

    // @Autowired optional with single constructor (Spring 4.3+)
    public BookService(BookRepository bookRepository,
                       NotificationService notificationService) {
        this.bookRepository = bookRepository;
        this.notificationService = notificationService;
    }
}
```

### Field Injection (Avoid)
```java
@Service
public class BookService {
    @Autowired  // ❌ fields not final, not testable without Spring
    private BookRepository bookRepository;
}
```

---

## 19. XML Configuration (Legacy Reference)

```xml
<!-- applicationContext.xml -->
<beans xmlns="http://www.springframework.org/schema/beans">

    <bean id="bookRepository" class="com.bookstore.repository.InMemoryBookRepository"/>

    <bean id="notificationService" class="com.bookstore.service.LoggingNotificationService"/>

    <bean id="bookService" class="com.bookstore.service.BookService">
        <constructor-arg ref="bookRepository"/>
        <constructor-arg ref="notificationService"/>
    </bean>

</beans>
```

```java
ApplicationContext context =
    new ClassPathXmlApplicationContext("applicationContext.xml");
BookService bookService = context.getBean("bookService", BookService.class);
```

You'll encounter this in legacy code. Don't write it for new projects.

---

## 20. Java `@Configuration` and `@Bean`

```java
@Configuration
public class AppConfig {

    @Bean
    public BookRepository bookRepository() {
        return new InMemoryBookRepository();
    }

    @Bean
    public NotificationService notificationService() {
        return new LoggingNotificationService();
    }

    @Bean
    public BookService bookService(BookRepository bookRepository,
                                   NotificationService notificationService) {
        return new BookService(bookRepository, notificationService);
    }
}
```

```java
ApplicationContext context =
    new AnnotationConfigApplicationContext(AppConfig.class);
BookService bookService = context.getBean(BookService.class);
```

**When to use `@Bean` methods:**
- Third-party classes you can't annotate with `@Component`
- Beans requiring complex construction logic
- Beans with conditional creation
- Integration with external libraries (DataSource, RestTemplate, etc.)

---

## 21. Bean Lifecycle

```
Spring Startup
     │
     ▼
1. Read configuration (scan annotations / @Configuration classes)
2. Instantiate beans in dependency order (call constructors)
3. Inject properties (@Value, setters)
4. Call @PostConstruct methods (initialization)
5. Bean is ready to use
     │
     ▼ (at application shutdown)
6. Call @PreDestroy methods (cleanup)
7. Destroy bean
```

```java
@Service
@RequiredArgsConstructor
public class BookCacheService {

    private final BookRepository bookRepository;
    private Map<Long, Book> cache;

    @PostConstruct
    public void init() {
        // Dependencies are injected — safe to use bookRepository here
        cache = new HashMap<>();
        bookRepository.findAll().forEach(book -> cache.put(book.getId(), book));
        log.info("Cache warmed with {} books", cache.size());
    }

    @PreDestroy
    public void cleanup() {
        cache.clear();
        log.info("Cache cleared on shutdown");
    }
}
```

---

## 22. Component Scanning and Stereotypes

```java
// Spring Boot — @SpringBootApplication includes @ComponentScan
// Scans com.bookstore and all sub-packages automatically
@SpringBootApplication
public class BookstoreApplication {
    public static void main(String[] args) {
        SpringApplication.run(BookstoreApplication.class, args);
    }
}
```

| Annotation | Extends | Use For | Extra Behavior |
|---|---|---|---|
| `@Component` | — | Generic Spring-managed class | None |
| `@Service` | `@Component` | Business logic layer | None (semantic only) |
| `@Repository` | `@Component` | Data access layer | Exception translation |
| `@Controller` | `@Component` | Spring MVC controllers | Request mapping |
| `@RestController` | `@Controller` | REST API controllers | Implicit `@ResponseBody` |

**Exception translation**: `@Repository` enables Spring to catch platform-specific exceptions (JDBC `SQLException`, JPA `PersistenceException`) and re-throw them as Spring's unified `DataAccessException` hierarchy. Your service layer doesn't need to know which data access technology is in use.

---

## 23. `@Autowired` and Ambiguity Resolution

```java
// Single constructor — @Autowired optional in Spring 4.3+
@Service
public class BookService {
    private final BookRepository bookRepository;

    public BookService(BookRepository bookRepository) {
        this.bookRepository = bookRepository;
    }
}
```

### Handling Multiple Implementations

```java
// Two beans implement BookRepository — Spring can't choose automatically
@Repository
@Primary  // ← Spring uses this one by default
public class SqlBookRepository implements BookRepository { ... }

@Repository
public class InMemoryBookRepository implements BookRepository { ... }
```

```java
// OR: specify exactly which implementation at the injection point
@Service
public class BookService {
    public BookService(@Qualifier("inMemoryBookRepository") BookRepository repo) {
        this.bookRepository = repo;
    }
}
```

```java
// OR: inject all implementations as a List
@Service
public class BookSearchService {
    public BookSearchService(List<BookRepository> repositories) {
        // repositories contains both SqlBookRepository and InMemoryBookRepository
    }
}
```

---

## 24. Bean Scopes

| Scope | Instances | Use For |
|---|---|---|
| `singleton` (default) | One per ApplicationContext | Stateless beans — services, repos, controllers |
| `prototype` | New instance per request | Stateful objects, command objects |
| `request` | One per HTTP request | Request-scoped state (web apps) |
| `session` | One per HTTP session | User session state (web apps) |
| `application` | One per ServletContext | App-wide shared state (web apps) |

```java
@Service
@Scope("prototype")  // new instance each time BookService is requested
public class OrderProcessor { ... }
```

**The golden rule**: If a singleton bean has mutable instance fields that vary per caller, you have a race condition. Singletons are shared across all concurrent requests. Use local variables, not instance fields, for per-request state.

---

## 25. Lombok Annotation Reference

| Annotation | Generates |
|---|---|
| `@Getter` | Getter for all fields |
| `@Setter` | Setter for all non-final fields |
| `@NoArgsConstructor` | No-argument constructor |
| `@AllArgsConstructor` | Constructor with all fields |
| `@RequiredArgsConstructor` | Constructor for all `final` and `@NonNull` fields |
| `@EqualsAndHashCode` | `equals()` and `hashCode()` using all non-static fields |
| `@ToString` | `toString()` with all fields |
| `@Data` | `@Getter` + `@Setter` + `@RequiredArgsConstructor` + `@EqualsAndHashCode` + `@ToString` |
| `@Value` | Immutable version of `@Data` — all fields final, no setters |
| `@Builder` | Builder pattern (`Book.builder().title("x").build()`) |
| `@Slf4j` | `private static final Logger log = LoggerFactory.getLogger(...)` |
| `@NonNull` | Adds null check at the top of the constructor/method |

---

## 26. Lombok + Spring Best Practices

### Services and Components — Recommended Pattern
```java
@Service
@RequiredArgsConstructor  // generates constructor for final fields
@Slf4j                    // generates log field
public class BookService {
    private final BookRepository bookRepository;
    private final NotificationService notificationService;

    public Book createBook(Book book) {
        log.info("Creating book: {}", book.getTitle());
        Book saved = bookRepository.save(book);
        notificationService.notify("Book created: " + saved.getTitle());
        return saved;
    }
}
```

### DTOs — Recommended Pattern
```java
@Data                     // getters + setters + equals + hashCode + toString
@NoArgsConstructor
@AllArgsConstructor
@Builder
public class BookDto {
    private Long id;
    private String title;
    private String author;
    private BigDecimal price;
}
```

### JPA Entities — Safe Lombok Pattern (covered fully on Day 27)
```java
@Entity
@Table(name = "books")
@Getter
@Setter
@NoArgsConstructor        // JPA requires no-arg constructor
@EqualsAndHashCode(of = "id")  // only use DB ID for equality — avoid infinite recursion
@ToString(exclude = "author")  // exclude relationships — avoid infinite recursion
public class Book {
    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private Long id;
    private String title;
}
```

### ⚠️ JPA Entity Warnings
| Annotation | Risk | Solution |
|---|---|---|
| `@Data` | `equals()`/`hashCode()` follows relationships → infinite recursion | Use `@EqualsAndHashCode(of = "id")` instead |
| `@Builder` | Suppresses no-arg constructor → JPA fails to instantiate entities | Add `@NoArgsConstructor` and `@AllArgsConstructor` explicitly |
| `@ToString` | Follows bidirectional relationships → `StackOverflowError` | Use `@ToString(exclude = "relationshipField")` |

---

## 27. Configuration Style Decision Guide

| Situation | Config Style |
|---|---|
| Your own classes with simple wiring | Component scanning (`@Service`, `@Repository`, etc.) |
| Third-party class (no access to source) | `@Bean` method in `@Configuration` class |
| Complex conditional construction logic | `@Bean` method in `@Configuration` class |
| Legacy project migration/maintenance | XML (understand it, don't write new XML) |
| Modern Spring Boot project default | Component scanning for most; `@Bean` for library integration |

---

## 28. Common Mistakes and Fixes

| Mistake | Symptom | Fix |
|---|---|---|
| Main class not in root package | Components not found, `NoSuchBeanDefinitionException` | Move main class to `com.yourcompany.yourapp` (root) |
| Forgot `annotationProcessor` for Lombok in Gradle | Getters not generated, `cannot find symbol` | Add `annotationProcessor 'org.projectlombok:lombok'` |
| `@Data` on JPA entity | `StackOverflowError` in toString/equals | Use `@Getter @Setter @EqualsAndHashCode(of="id") @ToString(exclude=...)` |
| `@Builder` on JPA entity without `@NoArgsConstructor` | JPA fails to instantiate | Add `@NoArgsConstructor @AllArgsConstructor` |
| Field injection with `@Autowired` | Cannot test without Spring context | Use constructor injection with `final` fields |
| Mutable state in singleton bean | Race conditions under concurrency | Use local variables or prototype scope |
| Two beans same type, no `@Primary`/`@Qualifier` | `NoUniqueBeanDefinitionException` at startup | Add `@Primary` to default implementation |
| `target/` or `build/` committed to git | Repository bloat | Add to `.gitignore` |

---

## 29. Quick Reference Cheat Sheet

### Maven
```bash
mvn clean package          # build project
mvn clean install          # build and install to local cache
mvn spring-boot:run        # run application
mvn test                   # run tests
mvn clean package -DskipTests  # build without tests
mvn dependency:tree        # show dependency tree
```

### Gradle
```bash
./gradlew build            # build project
./gradlew bootRun          # run application
./gradlew test             # run tests
./gradlew build -x test    # build without tests
./gradlew dependencies     # show dependency tree
./gradlew clean build      # clean then build
```

### Spring Core Annotations
```
@Component      generic Spring-managed bean
@Service        business logic layer
@Repository     data access layer (+ exception translation)
@Autowired      inject dependency (optional for single constructors)
@Primary        default when multiple beans of same type exist
@Qualifier      specify exact bean to inject
@Configuration  marks a class as containing @Bean methods
@Bean           declares a method that returns a Spring-managed bean
@Scope          change bean scope from default singleton
@PostConstruct  run after construction and injection
@PreDestroy     run before bean is destroyed
```

### Lombok for Services
```
@Service @RequiredArgsConstructor @Slf4j
private final ServiceDependency dependency;
log.info("message: {}", value);
```

---

## 30. Looking Ahead — Day 25: Spring Boot

Everything we did today — creating the `ApplicationContext`, configuring beans, setting up dependencies — Spring Boot automates. Day 25 covers:

- **Auto-configuration**: Spring Boot looks at your classpath and configures hundreds of beans automatically. No manual `ApplicationContext` setup, no explicit `@Configuration` for common components.
- **`application.properties` / `application.yml`**: Externalized configuration for database URLs, server ports, log levels.
- **Spring Boot starters**: Pre-packaged sets of dependencies for common needs (`spring-boot-starter-web`, `spring-boot-starter-data-jpa`, `spring-boot-starter-security`).
- **Actuator**: Production monitoring — health checks, metrics, info endpoints.
- **Profiles**: Different configurations for dev, test, and production environments.

The IoC container, dependency injection, component scanning, bean lifecycle — all of that is still happening exactly as you learned today. Spring Boot just removes the ceremony around setting it up.
