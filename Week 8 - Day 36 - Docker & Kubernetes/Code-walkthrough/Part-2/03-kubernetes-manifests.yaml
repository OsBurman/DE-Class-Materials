# =============================================================================
# Day 36 – Docker & Kubernetes | Part 2
# File: 03-kubernetes-manifests.yaml
# Topic: Complete K8s Manifests — Bookstore Application
# Domain: Bookstore Application
# =============================================================================
# Apply all manifests in order:
#   kubectl apply -f 03-kubernetes-manifests.yaml
# =============================================================================


# ─────────────────────────────────────────────────────────────────────────────
# 1. NAMESPACE
# ─────────────────────────────────────────────────────────────────────────────
apiVersion: v1
kind: Namespace
metadata:
  name: bookstore-ns
  labels:
    app: bookstore
    environment: dev

---

# ─────────────────────────────────────────────────────────────────────────────
# 2. CONFIGMAP — non-sensitive application configuration
# ─────────────────────────────────────────────────────────────────────────────
# ConfigMaps decouple configuration from the container image.
# Reference these values as environment variables or volume mounts in pods.
apiVersion: v1
kind: ConfigMap
metadata:
  name: bookstore-config
  namespace: bookstore-ns
  labels:
    app: bookstore
data:
  # Key: value — all values must be strings
  APP_PORT: "8080"
  SPRING_PROFILES_ACTIVE: "kubernetes"
  LOG_LEVEL: "INFO"
  DB_HOST: "postgres-service"         # Kubernetes service name — DNS resolves automatically
  DB_PORT: "5432"
  DB_NAME: "bookstore_db"
  JPA_DDL_AUTO: "update"
  # Multi-line value (full properties file mounted as a volume)
  application.properties: |
    server.port=8080
    spring.datasource.url=jdbc:postgresql://${DB_HOST}:${DB_PORT}/${DB_NAME}
    spring.jpa.hibernate.ddl-auto=update
    logging.level.root=INFO
    management.endpoints.web.exposure.include=health,info,metrics

---

# ─────────────────────────────────────────────────────────────────────────────
# 3. SECRET — sensitive credentials
# ─────────────────────────────────────────────────────────────────────────────
# Values under `data:` must be base64-encoded.
# Values under `stringData:` are plain text — K8s encodes them automatically.
# In production: use external secret managers (AWS Secrets Manager, HashiCorp Vault).
apiVersion: v1
kind: Secret
metadata:
  name: bookstore-secret
  namespace: bookstore-ns
  labels:
    app: bookstore
type: Opaque
stringData:                           # plain text (K8s base64-encodes on apply)
  DB_USERNAME: "admin"
  DB_PASSWORD: "super_secret_password"
  JWT_SECRET: "myJwtSigningKeyForProductionChangeMe"

# To verify what's stored (base64-encoded):
#   kubectl get secret bookstore-secret -n bookstore-ns -o jsonpath='{.data.DB_PASSWORD}' | base64 -d

---

# ─────────────────────────────────────────────────────────────────────────────
# 4. POD — (standalone Pod for demo/understanding only)
# ─────────────────────────────────────────────────────────────────────────────
# In production, NEVER create standalone Pods — use a Deployment.
# This example shows the Pod spec structure that Deployments use internally.
apiVersion: v1
kind: Pod
metadata:
  name: bookstore-pod-demo
  namespace: bookstore-ns
  labels:
    app: bookstore
    role: demo                        # This pod won't be selected by Services/Deployments
spec:
  containers:
    - name: bookstore-app
      image: scottb/bookstore:1.0.0
      ports:
        - containerPort: 8080         # Documents the port; does NOT expose it
      env:
        # Inject individual values from ConfigMap
        - name: APP_PORT
          valueFrom:
            configMapKeyRef:
              name: bookstore-config
              key: APP_PORT
        # Inject individual values from Secret
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: bookstore-secret
              key: DB_PASSWORD
      resources:
        requests:                     # Minimum resources the pod needs to be SCHEDULED
          cpu: "250m"                 # 250 millicores = 0.25 CPU
          memory: "256Mi"
        limits:                       # Maximum resources before K8s throttles/kills
          cpu: "500m"
          memory: "512Mi"
  restartPolicy: Always               # Always | OnFailure | Never

---

# ─────────────────────────────────────────────────────────────────────────────
# 5. DEPLOYMENT — bookstore Spring Boot application
# ─────────────────────────────────────────────────────────────────────────────
apiVersion: apps/v1
kind: Deployment
metadata:
  name: bookstore-deployment
  namespace: bookstore-ns
  labels:
    app: bookstore
    version: "1.0.0"
  annotations:
    deployment.kubernetes.io/revision: "1"
spec:
  # ── Replica count ─────────────────────────────────────────────────────────
  replicas: 3                         # Run 3 identical pods for high availability

  # ── Pod selector — Deployment manages pods with these labels ──────────────
  selector:
    matchLabels:
      app: bookstore                  # Must match template.metadata.labels below

  # ── Rolling update strategy ────────────────────────────────────────────────
  strategy:
    type: RollingUpdate
    rollingUpdate:
      maxSurge: 1                     # Create at most 1 extra pod during update (4 total)
      maxUnavailable: 0               # Keep all 3 replicas available at all times

  # ── Pod template — the spec for each pod the Deployment creates ────────────
  template:
    metadata:
      labels:
        app: bookstore                # Must match spec.selector.matchLabels
        version: "1.0.0"
    spec:
      # ── Init container — wait for Postgres to be ready ─────────────────────
      initContainers:
        - name: wait-for-postgres
          image: busybox:1.36
          command:
            - sh
            - -c
            - |
              until nc -z postgres-service 5432; do
                echo "Waiting for postgres-service:5432..."
                sleep 2
              done
              echo "Postgres is ready!"

      # ── Main application container ─────────────────────────────────────────
      containers:
        - name: bookstore-app
          image: scottb/bookstore:1.0.0
          imagePullPolicy: Always     # Always pull latest (use IfNotPresent for speed in dev)

          ports:
            - containerPort: 8080
              name: http

          # ── Environment variables from ConfigMap (all keys at once) ─────────
          envFrom:
            - configMapRef:
                name: bookstore-config
            - secretRef:
                name: bookstore-secret

          # ── Override individual env vars ─────────────────────────────────────
          env:
            - name: SPRING_DATASOURCE_URL
              value: "jdbc:postgresql://$(DB_HOST):$(DB_PORT)/$(DB_NAME)"
            - name: SPRING_DATASOURCE_USERNAME
              valueFrom:
                secretKeyRef:
                  name: bookstore-secret
                  key: DB_USERNAME
            - name: SPRING_DATASOURCE_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: bookstore-secret
                  key: DB_PASSWORD

          # ── Resource requests and limits ─────────────────────────────────────
          resources:
            requests:
              cpu: "250m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"

          # ── Liveness Probe — is the container alive? ──────────────────────────
          # If this fails, K8s RESTARTS the container
          livenessProbe:
            httpGet:
              path: /actuator/health/liveness
              port: 8080
            initialDelaySeconds: 30   # Wait 30s for JVM startup before first check
            periodSeconds: 10         # Check every 10 seconds
            failureThreshold: 3       # Restart after 3 consecutive failures
            timeoutSeconds: 5

          # ── Readiness Probe — is the container READY to receive traffic? ───────
          # If this fails, K8s removes the pod from Service load balancing (no restarts)
          readinessProbe:
            httpGet:
              path: /actuator/health/readiness
              port: 8080
            initialDelaySeconds: 20
            periodSeconds: 5
            failureThreshold: 3
            timeoutSeconds: 3

          # ── Startup Probe — for slow-starting apps (Spring Boot is sometimes slow) ─
          # Disables liveness and readiness checks until app has started
          startupProbe:
            httpGet:
              path: /actuator/health
              port: 8080
            initialDelaySeconds: 10
            periodSeconds: 5
            failureThreshold: 24      # Give app up to 10 + (24*5) = 130s to start

          # ── Volume mounts ─────────────────────────────────────────────────────
          volumeMounts:
            - name: app-logs
              mountPath: /app/logs
            - name: config-volume
              mountPath: /app/config
              readOnly: true

      # ── Volumes ───────────────────────────────────────────────────────────────
      volumes:
        - name: app-logs
          emptyDir: {}                # Ephemeral — cleared when pod is deleted
        - name: config-volume
          configMap:
            name: bookstore-config
            items:
              - key: application.properties
                path: application.properties

---

# ─────────────────────────────────────────────────────────────────────────────
# 6. SERVICE — ClusterIP (internal communication)
# ─────────────────────────────────────────────────────────────────────────────
# ClusterIP services are only reachable WITHIN the cluster.
# Other services/pods use the service name as a DNS hostname.
apiVersion: v1
kind: Service
metadata:
  name: bookstore-clusterip
  namespace: bookstore-ns
  labels:
    app: bookstore
spec:
  type: ClusterIP                     # Default type — internal cluster IP
  selector:
    app: bookstore                    # Routes traffic to pods with label app=bookstore
  ports:
    - name: http
      protocol: TCP
      port: 80                        # Port clients use to reach the service
      targetPort: 8080                # Port on the container (must match containerPort)

---

# ─────────────────────────────────────────────────────────────────────────────
# 7. SERVICE — NodePort (external access via node IP)
# ─────────────────────────────────────────────────────────────────────────────
# Opens a static port on EVERY node in the cluster.
# Access via: http://<any-node-ip>:30080
# Useful for local dev (Minikube, Docker Desktop).
apiVersion: v1
kind: Service
metadata:
  name: bookstore-nodeport
  namespace: bookstore-ns
  labels:
    app: bookstore
spec:
  type: NodePort
  selector:
    app: bookstore
  ports:
    - name: http
      protocol: TCP
      port: 80                        # ClusterIP port (internal)
      targetPort: 8080                # Container port
      nodePort: 30080                 # External port on the node (30000–32767)

---

# ─────────────────────────────────────────────────────────────────────────────
# 8. SERVICE — LoadBalancer (cloud load balancer)
# ─────────────────────────────────────────────────────────────────────────────
# On AWS/GCP/Azure: provisions a cloud load balancer with an external IP.
# On local (Minikube/Docker Desktop): external IP stays <pending> unless you use
#   `minikube tunnel` or a tool like MetalLB.
apiVersion: v1
kind: Service
metadata:
  name: bookstore-loadbalancer
  namespace: bookstore-ns
  labels:
    app: bookstore
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "nlb"  # AWS-specific annotation
spec:
  type: LoadBalancer
  selector:
    app: bookstore
  ports:
    - name: http
      protocol: TCP
      port: 80
      targetPort: 8080

---

# ─────────────────────────────────────────────────────────────────────────────
# 9. POSTGRES DEPLOYMENT (StatefulSet simplified as Deployment for demo)
# ─────────────────────────────────────────────────────────────────────────────
# Production note: Use a StatefulSet for databases — stable network identity,
# ordered pod startup, and stable persistent volume claim per pod.
# For this demo we use a Deployment to keep things simpler.
apiVersion: apps/v1
kind: Deployment
metadata:
  name: postgres-deployment
  namespace: bookstore-ns
  labels:
    app: postgres
spec:
  replicas: 1                         # Databases typically run as a single instance
  selector:
    matchLabels:
      app: postgres
  template:
    metadata:
      labels:
        app: postgres
    spec:
      containers:
        - name: postgres
          image: postgres:15-alpine
          ports:
            - containerPort: 5432
          env:
            - name: POSTGRES_DB
              valueFrom:
                configMapKeyRef:
                  name: bookstore-config
                  key: DB_NAME
            - name: POSTGRES_USER
              valueFrom:
                secretKeyRef:
                  name: bookstore-secret
                  key: DB_USERNAME
            - name: POSTGRES_PASSWORD
              valueFrom:
                secretKeyRef:
                  name: bookstore-secret
                  key: DB_PASSWORD
          resources:
            requests:
              cpu: "250m"
              memory: "256Mi"
            limits:
              cpu: "500m"
              memory: "512Mi"
          livenessProbe:
            exec:
              command: ["pg_isready", "-U", "admin", "-d", "bookstore_db"]
            initialDelaySeconds: 20
            periodSeconds: 10
          volumeMounts:
            - name: postgres-data
              mountPath: /var/lib/postgresql/data
      volumes:
        - name: postgres-data
          persistentVolumeClaim:
            claimName: postgres-pvc

---

# ─────────────────────────────────────────────────────────────────────────────
# 10. PERSISTENT VOLUME CLAIM — Postgres data storage
# ─────────────────────────────────────────────────────────────────────────────
# K8s automatically provisions a PersistentVolume to satisfy this claim.
# On cloud: creates an EBS volume (AWS), Persistent Disk (GCP), etc.
# On local: uses the default storage class (hostPath on Docker Desktop).
apiVersion: v1
kind: PersistentVolumeClaim
metadata:
  name: postgres-pvc
  namespace: bookstore-ns
spec:
  accessModes:
    - ReadWriteOnce                   # One node can read/write at a time
  resources:
    requests:
      storage: 1Gi

---

# ─────────────────────────────────────────────────────────────────────────────
# 11. SERVICE — Postgres ClusterIP (internal only)
# ─────────────────────────────────────────────────────────────────────────────
# The bookstore app references this service by name: "postgres-service"
# (configured in bookstore-config's DB_HOST key)
apiVersion: v1
kind: Service
metadata:
  name: postgres-service
  namespace: bookstore-ns
  labels:
    app: postgres
spec:
  type: ClusterIP
  selector:
    app: postgres
  ports:
    - name: postgres
      protocol: TCP
      port: 5432
      targetPort: 5432

---

# ─────────────────────────────────────────────────────────────────────────────
# 12. HORIZONTAL POD AUTOSCALER (HPA)
# ─────────────────────────────────────────────────────────────────────────────
# Automatically scales the Deployment between minReplicas and maxReplicas
# based on CPU utilization (requires metrics-server to be installed).
apiVersion: autoscaling/v2
kind: HorizontalPodAutoscaler
metadata:
  name: bookstore-hpa
  namespace: bookstore-ns
spec:
  scaleTargetRef:
    apiVersion: apps/v1
    kind: Deployment
    name: bookstore-deployment
  minReplicas: 2                      # Never scale below 2 pods
  maxReplicas: 10                     # Never exceed 10 pods
  metrics:
    - type: Resource
      resource:
        name: cpu
        target:
          type: Utilization
          averageUtilization: 70      # Scale up when avg CPU > 70%
    - type: Resource
      resource:
        name: memory
        target:
          type: Utilization
          averageUtilization: 80      # Scale up when avg memory > 80%

# Check HPA status:
#   kubectl get hpa -n bookstore-ns
#   kubectl describe hpa bookstore-hpa -n bookstore-ns
