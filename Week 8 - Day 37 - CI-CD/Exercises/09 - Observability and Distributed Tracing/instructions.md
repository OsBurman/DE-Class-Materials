# Exercise 09 — Observability and Distributed Tracing

## Overview

Modern applications are composed of many services that collaborate to handle a single user request. When something goes wrong — or is just slow — logs from a single service rarely tell the whole story. **Distributed tracing** fills that gap by stitching together the timeline of every service involved in a request. In this exercise you will learn what a trace is, how context propagates between services, how OpenTelemetry works architecturally, and how to add tracing to a Spring Boot application.

---

## Learning Objectives

By the end of this exercise you will be able to:

- Define a **trace** and a **span**, and explain their parent/child relationship
- Explain how trace context is propagated across service boundaries via HTTP headers
- Describe the OpenTelemetry architecture: instrumentation → Collector → exporter
- Identify the Spring Boot dependencies needed to emit traces
- Explain how correlation IDs in logs connect log lines to a specific trace
- State where distributed tracing fits into a CI/CD pipeline and an observability stack

---

## Requirement 1 — Traces and Spans

Answer the following questions:

1. What is a **trace**? What does it represent end-to-end?
2. What is a **span**? What information does a single span record?
3. Describe the **parent/child relationship** between spans. How does a call from Service A to Service B create a new span?
4. If a user request passes through an API Gateway, then an Order Service, then a Payment Service, draw a simple ASCII diagram showing the trace as a tree of spans. Label each span with a service name and a hypothetical duration.

---

## Requirement 2 — Context Propagation

When a service makes an outbound HTTP call, it must forward the trace context so the receiving service can attach its span to the same trace.

1. Name **two HTTP header standards** used for context propagation and identify which specification each comes from.
2. What two pieces of information does a propagation header typically carry? (Hint: IDs.)
3. What happens to the trace if a downstream service **does not** forward the context header?
4. Does Spring Boot with Micrometer Tracing propagate context automatically, or must a developer write code to inject/extract headers manually?

---

## Requirement 3 — OpenTelemetry Architecture

OpenTelemetry (OTel) is a vendor-neutral observability framework.

1. List the **three signals** OpenTelemetry is designed to collect.
2. Describe the role of each component in the pipeline below:

```
[ Application (instrumented) ] → [ OTel Collector ] → [ Backend (Jaeger / Prometheus / Loki) ]
```

3. What is the **OTLP** protocol? Why is it preferred over sending data directly to a vendor-specific endpoint?
4. What is the difference between a **push** exporter (OTLP gRPC/HTTP) and a **pull** exporter (Prometheus scrape)?

---

## Requirement 4 — Spring Boot Tracing Configuration

A Spring Boot application needs two Maven dependencies to emit traces via OpenTelemetry.

1. Name the **two required Maven dependencies** (provide the `artifactId` values):
   - The Micrometer tracing bridge that connects to OTel
   - The OTLP exporter

2. In `application.yml`, write the configuration snippet that:
   - Sets the OTLP endpoint for trace export to `http://otel-collector:4318/v1/traces`
   - Sets the **sampling probability** to `1.0` (100% — sample every request)
   - Sets the application name to `order-service`

3. With tracing enabled, log output changes. Show an example log line that includes `traceId` and `spanId` fields. Explain what those values allow an engineer to do.

---

## Requirement 5 — Correlation IDs and Log Correlation

1. What is **MDC (Mapped Diagnostic Context)** in a Java logging framework (Logback / Log4j2)?
2. How does Spring Boot with Micrometer Tracing automatically populate MDC with trace context?
3. If an engineer sees the following in Kibana/Grafana Loki:

   ```
   ERROR 2024-03-15 14:32:07 [order-service] [traceId=4bf92f3577b34da6a3ce929d0e0e4736 spanId=00f067aa0ba902b7] PaymentService - Connection refused
   ```

   Explain **step-by-step** how they would use the `traceId` to investigate the problem in Jaeger.

4. What is the difference between a **trace ID** (auto-generated by OTel) and a **correlation ID** (manually set by a developer)?

---

## Requirement 6 — Tracing in the Context of CI/CD

1. Does distributed tracing run **inside** a CI/CD pipeline (e.g., during `mvn test`)? Explain why or why not.
2. How might a **performance regression** in production first be detected using tracing?
3. Complete the table below comparing the three observability signals for a specific failure scenario — a checkout request that is consistently taking 8 seconds:

| Signal | Tool | What it shows for this scenario |
|--------|------|----------------------------------|
| Metrics | Prometheus / Grafana | |
| Logs | ELK / Grafana Loki | |
| Traces | Jaeger / Zipkin | |

4. Why is it said that **traces are the "glue"** between metrics and logs?

---

## Deliverables

Complete all answer sections in `starter-code/answers.md`.  
Compare your completed answers with `solution/answers.md`.
