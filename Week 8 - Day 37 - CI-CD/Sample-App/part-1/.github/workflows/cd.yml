# ─────────────────────────────────────────────────────────────────────────────
# CD Workflow: Deploy
# File location: .github/workflows/cd.yml
#
# PURPOSE: Continuous Deployment — builds a Docker image and deploys it
# to staging automatically, then to production with manual approval.
#
# WHEN IT RUNS:
#   - Automatic: push to main branch
#   - Manual:    workflow_dispatch (trigger from Actions UI with environment choice)
#
# PREREQUISITES:
#   - A Dockerfile must exist in the repository root
#   - GitHub Container Registry (ghcr.io) enabled for the repository
# ─────────────────────────────────────────────────────────────────────────────

name: CD - Deploy

# ── Trigger Events ────────────────────────────────────────────────────────────
on:
  # Automatic: runs whenever code is pushed to main
  push:
    branches: [ main ]

  # Manual: allows triggering from the GitHub Actions UI with parameters.
  # 'workflow_dispatch' is essential for controlled production deployments.
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target environment'
        required: true
        default: 'staging'
        type: choice
        options: [ staging, production ]

# ── Environment Variables ─────────────────────────────────────────────────────
# 'env' at the workflow level are available to ALL jobs and steps.
# REGISTRY: GitHub Container Registry — free for public repos, included for private.
# IMAGE_NAME: uses the repository name (e.g., myorg/cicd-demo) as the image name.
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository }}

# ── Jobs ──────────────────────────────────────────────────────────────────────
jobs:

  # ── Job 1: Build and Push Docker Image ────────────────────────────────────
  build-docker:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest

    # 'permissions' grants this job specific GitHub token capabilities.
    # 'packages: write' is required to push images to ghcr.io.
    # Scoping permissions to the minimum needed is a security best practice.
    permissions:
      contents: read
      packages: write

    steps:
      - uses: actions/checkout@v4

      - name: Set up Java 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: maven

      # Build the JAR and inject the git commit SHA as the app version.
      # This makes it easy to trace which commit is running in any environment.
      - name: Build JAR
        run: mvn package -DskipTests -DAPP_VERSION=${{ github.sha }}

      # ── Log In to Container Registry ──────────────────────────────────────
      # GITHUB_TOKEN is an auto-generated token scoped to this workflow run.
      # It has permission to push to ghcr.io for THIS repository.
      # No manual secret setup required — GitHub provides it automatically.
      - name: Log in to Container Registry
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}

      # ── Build and Push Docker Image ────────────────────────────────────────
      # Builds the image using your Dockerfile and pushes it with two tags:
      #   :latest     — always points to the most recent build from main
      #   :<sha>      — immutable tag for this specific commit (enables rollback)
      #
      # Rollback example:
      #   docker run ghcr.io/myorg/cicd-demo:abc1234  ← pin to a specific commit
      - name: Build and Push Docker Image
        uses: docker/build-push-action@v5
        with:
          context: .
          push: true
          tags: |
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
            ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${{ github.sha }}

  # ── Job 2: Deploy to Staging ───────────────────────────────────────────────
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    # Wait for the Docker image to be built and pushed before deploying.
    needs: build-docker

    # 'environment' links this job to a named GitHub Environment.
    # Benefits:
    #   1. Environment-specific secrets (staging DB URL, staging API key, etc.)
    #   2. Protection rules (required reviewers, wait timers)
    #   3. Deployment history visible in GitHub UI
    # Configure environments at: Repository Settings > Environments
    environment: staging

    steps:
      - name: Deploy to Staging
        # In a real project, replace this with your actual deploy command:
        #   SSH:       ssh user@host "docker pull $IMAGE && docker run ..."
        #   Kubernetes: kubectl set image deployment/app app=$IMAGE
        #   AWS ECS:   aws ecs update-service --service app --force-new-deployment
        #   Heroku:    heroku container:push web -a myapp && heroku container:release web -a myapp
        run: |
          echo "Deploying ${{ github.sha }} to staging"
          echo "In production: use SSH, kubectl, AWS CLI, or Heroku CLI here"

      - name: Run Smoke Tests
        # Smoke tests are a minimal set of checks to verify the deployment succeeded.
        # They should complete in seconds and test the most critical paths.
        run: |
          echo "Running smoke tests against staging..."
          echo "In production: curl https://staging.myapp.com/actuator/health"
          echo "Expected response: {\"status\":\"UP\"}"

  # ── Job 3: Deploy to Production ───────────────────────────────────────────
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging

    # The 'production' environment should have "Required reviewers" configured.
    # When this job reaches the environment gate, GitHub:
    #   1. Pauses the workflow
    #   2. Sends a notification to the required reviewers
    #   3. Waits for approval before proceeding
    # Configure at: Repository Settings > Environments > production > Required reviewers
    environment: production

    # Only deploy to production when manually triggered AND explicitly chosen.
    # Protects against accidental production deploys on every push to main.
    if: github.event_name == 'workflow_dispatch' && github.event.inputs.environment == 'production'

    steps:
      - name: Deploy to Production
        run: |
          echo "Deploying to production with manual approval gate"
          echo "In production: same as staging but on production infrastructure"
          echo "Tip: tag the git commit after a successful production deploy"
          echo "     git tag -a v1.0.0 -m 'Release 1.0.0' && git push origin v1.0.0"
