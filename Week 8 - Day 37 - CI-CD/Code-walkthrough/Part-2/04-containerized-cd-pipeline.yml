# =============================================================================
# Day 37 â€“ CI/CD & DevOps | Part 2
# File: 04-containerized-cd-pipeline.yml
# Topic: End-to-End CD Pipeline â€” Docker Build, Push, Deploy to Kubernetes
#        + CI/CD Best Practices for Teams
# Domain: Bookstore Spring Boot Application
# =============================================================================
# This is the CONTINUOUS DELIVERY portion of the pipeline.
# It picks up where 02-github-actions-pipeline.yml (CI) left off.
#
# Full flow:
#   Code push â†’ CI pipeline (build/test/quality) â†’ CD pipeline (docker/deploy)
#
# Place at: .github/workflows/cd.yml
# =============================================================================

name: Bookstore CD Pipeline

on:
  # Triggered after CI pipeline completes successfully on main
  workflow_run:
    workflows: ["Bookstore CI Pipeline"]
    types: [completed]
    branches: [main]

  # Also allow manual trigger with environment selection
  workflow_dispatch:
    inputs:
      environment:
        description: 'Target deployment environment'
        required: true
        type: choice
        options:
          - staging
          - production
      image_tag:
        description: 'Docker image tag to deploy (leave empty to use latest)'
        required: false
        type: string

# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
# ENVIRONMENT VARIABLES
# â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
env:
  REGISTRY: ghcr.io
  IMAGE_NAME: ${{ github.repository_owner }}/bookstore-app
  # The K8s deployment name and namespace (from 03-kubernetes-manifests.yaml)
  DEPLOYMENT_NAME: bookstore-deployment
  K8S_NAMESPACE: bookstore-ns

jobs:
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # Only proceed if the CI pipeline succeeded
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  check-ci-status:
    runs-on: ubuntu-latest
    if: >
      github.event_name == 'workflow_dispatch' ||
      github.event.workflow_run.conclusion == 'success'
    steps:
      - name: CI pipeline status check
        run: echo "âœ… CI pipeline passed â€” proceeding with deployment"

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 1: BUILD AND PUSH DOCKER IMAGE
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  docker-build-push:
    name: Build and Push Docker Image
    runs-on: ubuntu-latest
    needs: check-ci-status

    # Export outputs so downstream jobs can use the image tag
    outputs:
      image_tag:    ${{ steps.meta.outputs.tags }}
      version_tag:  ${{ steps.version.outputs.tag }}

    steps:
      # â”€â”€ Step 1: Checkout â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout code
        uses: actions/checkout@v4

      # â”€â”€ Step 2: Set up QEMU (for multi-platform builds) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Allows building linux/amd64 AND linux/arm64 images simultaneously
      - name: Set up QEMU
        uses: docker/setup-qemu-action@v3

      # â”€â”€ Step 3: Set up Docker Buildx (enhanced builder) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      # â”€â”€ Step 4: Authenticate to GitHub Container Registry (GHCR) â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Log in to GHCR
        uses: docker/login-action@v3
        with:
          registry: ${{ env.REGISTRY }}
          username: ${{ github.actor }}
          password: ${{ secrets.GITHUB_TOKEN }}   # Auto-provided by GitHub

      # â”€â”€ Step 5: Generate image metadata (tags and labels) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Automatically tags with: branch name, semver, latest, commit SHA
      - name: Extract Docker metadata
        id: meta
        uses: docker/metadata-action@v5
        with:
          images: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}
          tags: |
            type=raw,value=latest,enable={{is_default_branch}}
            type=sha,prefix=sha-
            type=raw,value=1.0.0-build.${{ github.run_number }}

      # â”€â”€ Step 6: Generate our own version tag â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Set version tag
        id: version
        run: |
          VERSION_TAG="1.0.0-build.${{ github.run_number }}"
          echo "tag=${VERSION_TAG}" >> $GITHUB_OUTPUT
          echo "IMAGE_TAG=${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}" >> $GITHUB_ENV

      # â”€â”€ Step 7: Build Java application â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Download cached dependencies before building
      - name: Set up JDK 17
        uses: actions/setup-java@v4
        with:
          java-version: '17'
          distribution: 'temurin'
          cache: 'maven'

      - name: Build JAR
        run: mvn package -DskipTests --no-transfer-progress

      # â”€â”€ Step 8: Build and push multi-platform Docker image â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # This is the key step â€” builds the image defined in your Dockerfile
      # and pushes it directly to GHCR.
      - name: Build and push Docker image
        id: build
        uses: docker/build-push-action@v5
        with:
          context: .
          file: ./Dockerfile
          platforms: linux/amd64,linux/arm64    # Multi-architecture (Intel + Apple Silicon)
          push: true
          tags: ${{ steps.meta.outputs.tags }}
          labels: ${{ steps.meta.outputs.labels }}
          # Layer caching â€” reuse unchanged layers between builds
          cache-from: type=gha
          cache-to:   type=gha,mode=max
          build-args: |
            BUILD_DATE=${{ github.event.head_commit.timestamp }}
            GIT_COMMIT=${{ github.sha }}
            VERSION=${{ steps.version.outputs.tag }}

      # â”€â”€ Step 9: Output the image digest for traceability â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Image digest
        run: |
          echo "Image pushed: ${{ steps.meta.outputs.tags }}"
          echo "Digest: ${{ steps.build.outputs.digest }}"

      # â”€â”€ Step 10: Scan image for vulnerabilities (shift-left security) â”€â”€â”€â”€â”€
      - name: Run Trivy vulnerability scanner
        uses: aquasecurity/trivy-action@master
        with:
          image-ref: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:latest
          format: table
          exit-code: '1'           # Fail the pipeline on CRITICAL vulnerabilities
          ignore-unfixed: true
          severity: 'CRITICAL,HIGH'

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 2: DEPLOY TO STAGING
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-staging:
    name: Deploy to Staging
    runs-on: ubuntu-latest
    needs: docker-build-push
    environment:
      name: staging                 # GitHub Environment with protection rules
      url: https://staging.bookstore.com

    steps:
      # â”€â”€ Step 1: Checkout (for K8s manifests) â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Checkout
        uses: actions/checkout@v4

      # â”€â”€ Step 2: Configure kubectl for staging cluster â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # Kubeconfig is stored as a GitHub secret (base64-encoded YAML)
      - name: Configure kubectl
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.STAGING_KUBECONFIG }}

      # â”€â”€ Step 3: Verify cluster connection â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verify cluster access
        run: |
          kubectl cluster-info
          kubectl get nodes

      # â”€â”€ Step 4: Update the image in the Deployment (rolling update) â”€â”€â”€â”€â”€â”€â”€
      - name: Deploy new image (rolling update)
        run: |
          VERSION_TAG="${{ needs.docker-build-push.outputs.version_tag }}"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}"

          echo "Deploying image: ${FULL_IMAGE}"

          kubectl set image deployment/${{ env.DEPLOYMENT_NAME }} \
            bookstore-app=${FULL_IMAGE} \
            -n ${{ env.K8S_NAMESPACE }}

      # â”€â”€ Step 5: Wait for rollout to complete â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Wait for rollout
        run: |
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.K8S_NAMESPACE }} \
            --timeout=5m              # Fail deployment if not ready within 5 min

      # â”€â”€ Step 6: Verify pods are running â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Verify deployment
        run: |
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} -l app=bookstore
          kubectl get pods -n ${{ env.K8S_NAMESPACE }} \
            -o jsonpath='{range .items[*]}{.metadata.name}{"\t"}{.spec.containers[0].image}{"\n"}{end}'

      # â”€â”€ Step 7: Smoke tests against staging â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Smoke test â€” health endpoint
        run: |
          echo "Running smoke tests against staging..."
          for i in {1..10}; do
            STATUS=$(curl -s -o /dev/null -w "%{http_code}" \
              https://staging.bookstore.com/actuator/health)
            if [ "$STATUS" = "200" ]; then
              echo "âœ… Health check passed (attempt $i)"
              break
            fi
            echo "Attempt $i â€” HTTP $STATUS â€” retrying in 10s..."
            if [ $i -eq 10 ]; then
              echo "âŒ Smoke test failed after 10 attempts"
              exit 1
            fi
            sleep 10
          done

      - name: Smoke test â€” list books
        run: |
          RESPONSE=$(curl -s https://staging.bookstore.com/books)
          COUNT=$(echo "$RESPONSE" | jq 'length')
          if [ "$COUNT" -gt "0" ]; then
            echo "âœ… Books endpoint returned $COUNT books"
          else
            echo "âŒ Books endpoint returned empty â€” possible data migration failure"
            exit 1
          fi

      # â”€â”€ Step 8: Rollback on smoke test failure â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      - name: Rollback on failure
        if: failure()
        run: |
          echo "ğŸ”„ Smoke tests failed â€” rolling back deployment"
          kubectl rollout undo deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.K8S_NAMESPACE }}
          kubectl rollout status deployment/${{ env.DEPLOYMENT_NAME }} \
            -n ${{ env.K8S_NAMESPACE }}

  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  # JOB 3: DEPLOY TO PRODUCTION (requires manual approval)
  # â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    needs: deploy-staging
    environment:
      name: production              # GitHub Environment with required reviewers configured
      url: https://bookstore.com
    # NOTE: Production deployment is gated by GitHub Environment protection rules.
    # Go to: Settings â†’ Environments â†’ production â†’ Required reviewers
    # The workflow pauses here until an authorized reviewer approves.

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure kubectl (production)
        uses: azure/k8s-set-context@v3
        with:
          method: kubeconfig
          kubeconfig: ${{ secrets.PRODUCTION_KUBECONFIG }}

      # â”€â”€ Blue-Green cutover in production â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
      # (Demonstrates blue-green â€” update green, validate, switch service)
      - name: Deploy to green slot
        run: |
          VERSION_TAG="${{ needs.docker-build-push.outputs.version_tag }}"
          FULL_IMAGE="${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}:${VERSION_TAG}"

          # Update the green deployment image
          kubectl set image deployment/bookstore-green \
            bookstore-app=${FULL_IMAGE} \
            -n ${{ env.K8S_NAMESPACE }}

          kubectl rollout status deployment/bookstore-green \
            -n ${{ env.K8S_NAMESPACE }} --timeout=5m

      - name: Run pre-cutover smoke tests on green
        run: |
          # Port-forward to green for pre-cutover testing
          kubectl port-forward deployment/bookstore-green 8081:8080 \
            -n ${{ env.K8S_NAMESPACE }} &
          sleep 5
          curl -f http://localhost:8081/actuator/health

      - name: Cut over to green (blue-green switch)
        run: |
          # Switch the Service selector from blue â†’ green
          kubectl patch service bookstore-service \
            -n ${{ env.K8S_NAMESPACE }} \
            -p '{"spec":{"selector":{"slot":"green"}}}'
          echo "âœ… Traffic switched to green (v${{ needs.docker-build-push.outputs.version_tag }})"

      - name: Tag old blue deployment for future rollback
        run: |
          kubectl annotate deployment/bookstore-blue \
            -n ${{ env.K8S_NAMESPACE }} \
            deployment.kubernetes.io/previous-version="1.0.0" --overwrite

      - name: Notify team of production deploy
        run: |
          echo "ğŸš€ Production deployment complete!"
          echo "Version: ${{ needs.docker-build-push.outputs.version_tag }}"
          echo "Image: ${{ env.REGISTRY }}/${{ env.IMAGE_NAME }}"
          # curl -X POST ${{ secrets.SLACK_WEBHOOK }} \
          #   -H 'Content-type: application/json' \
          #   --data "{\"text\":\"ğŸš€ Bookstore ${{ needs.docker-build-push.outputs.version_tag }} deployed to production!\"}"

# =============================================================================
# CI/CD BEST PRACTICES FOR TEAMS â€” Reference Guide
# =============================================================================
#
# 1. BRANCH STRATEGY
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    main         â†’ protected, requires CI pass + PR review
#    develop      â†’ integration branch for feature PRs
#    feature/xxx  â†’ short-lived feature branches
#    hotfix/xxx   â†’ emergency fixes directly to main
#
#    GitHub Branch Protection Rules (Settings â†’ Branches â†’ main):
#      â˜‘ Require pull request reviews (at least 1)
#      â˜‘ Require status checks to pass (CI pipeline)
#      â˜‘ Require branches to be up to date
#      â˜‘ Restrict force pushes
#
# 2. COMMIT HYGIENE
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    Conventional Commits format:
#      feat: add book recommendation endpoint
#      fix: resolve null pointer in order service
#      test: add integration tests for checkout
#      chore: upgrade Spring Boot to 3.2.0
#      docs: update API documentation
#
#    Small, focused commits â†’ easier to revert and bisect bugs
#    Commit message should explain WHY, not just what
#
# 3. PULL REQUEST PRACTICES
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    â†’ Keep PRs small (< 400 lines changed)
#    â†’ Link to issue/ticket in description
#    â†’ Self-review before requesting reviews
#    â†’ CI must pass before review is requested
#    â†’ Address all review comments before merge
#
# 4. SECRET MANAGEMENT
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    Never commit secrets to Git (not even in private repos).
#    Use:
#      - GitHub Secrets (Settings â†’ Secrets â†’ Actions)
#      - AWS Secrets Manager / GCP Secret Manager / Azure Key Vault
#      - HashiCorp Vault for self-hosted
#    Rotate secrets regularly. Audit access.
#
# 5. PIPELINE PERFORMANCE
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    â†’ Cache dependencies (Maven ~/.m2, npm node_modules)
#    â†’ Run independent stages in parallel
#    â†’ Fail fast â€” compile before testing
#    â†’ Use Docker layer caching (cache-from: type=gha)
#    â†’ Target: CI pipeline < 10 minutes for developer feedback loop
#
# 6. ENVIRONMENT PARITY
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    Dev â‰ˆ Staging â‰ˆ Production (same OS, same dependencies, same config structure)
#    Use containers + IaC to enforce parity
#    Use environment variables + ConfigMaps for env-specific values
#    Never promote "works on my machine" â€” use the pipeline artifact
#
# 7. ROLLBACK PLAN
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    Always have a tested rollback procedure before deploying.
#    Rolling updates: kubectl rollout undo
#    Blue-green: switch service selector back to blue
#    Canary: scale down canary to 0
#    Test rollback in staging regularly
#
# 8. OBSERVABILITY IN THE PIPELINE
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    â†’ Smoke tests after every deployment
#    â†’ Monitor error rate for 5â€“15 min after production deploy
#    â†’ Automated rollback trigger: if error rate spikes post-deploy
#    â†’ Link deployment events to your monitoring dashboard
#      (annotate Grafana with deployment markers)
#
# 9. DOCUMENTATION
#    â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#    â†’ README with: setup, run, test, deploy instructions
#    â†’ CONTRIBUTING.md with: branch strategy, commit conventions, PR process
#    â†’ RUNBOOKS for: deployment, rollback, incident response
#    â†’ Architecture Decision Records (ADRs) for significant decisions
#
# 10. TEAM COLLABORATION
#     â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€
#     â†’ Shared CI/CD dashboard visible to whole team
#     â†’ Deployments announced in team channel (Slack/Teams)
#     â†’ Blameless post-mortems when things go wrong
#     â†’ Rotate on-call responsibility
#     â†’ "Red builds must be fixed immediately" culture â€” don't ignore failures
