OPENING (5 minutes)
[Slide: Title slide — "React Fundamentals" with your name, date, and a simple React logo]
"Good morning everyone. Today we're going to dig into the core concepts that make React one of the most widely used tools in modern web development. Some of what we cover today you've touched on before — I want to build on that foundation and make sure everything clicks together by the end of this session.
By the time we're done, you should be able to look at a React codebase and understand what's happening, why it's structured the way it is, and how data moves through it. We're going to write some code together, look at a lot of examples, and I'll stop for questions throughout.
Let's get started."

SECTION 1: React Overview and Philosophy (8 minutes)
[Slide: "What is React?" — Bullet points: "A JavaScript library for building user interfaces", "Created by Facebook, open-sourced in 2013", "Component-based architecture", "Declarative, not imperative"]
"React is not a framework — and that distinction matters. It's a library, which means it focuses on doing one thing really well: building user interfaces. Everything else — routing, state management at scale, server communication — those are handled by other tools you'll bring in alongside React.
React was built at Facebook to solve a very real problem they were having: their UI was getting incredibly complex and hard to keep in sync. When someone got a new message notification, five different parts of the page needed to update. Managing all of that by hand with vanilla JavaScript was becoming a nightmare.
[Slide: "Declarative vs Imperative" — Two columns showing a simple counter in vanilla JS imperatively (manually selecting DOM elements, updating innerHTML) vs React declaratively (just describing what the UI should look like)]
The core philosophy of React is that you should describe what your UI should look like given a certain state of data — not tell the browser how to get there step by step. That's the difference between declarative and imperative programming.
In vanilla JavaScript, you might say: 'Get the element with this ID, change its text content, now find this other element, add a class to it.' You're giving instructions. In React, you say: 'When the count is 5, the UI looks like this.' React figures out how to make that happen. This makes your code much easier to reason about, especially as applications grow.
The second big idea in React is component-based architecture. Everything in React is a component — a self-contained, reusable piece of UI. Think about a webpage. You have a navigation bar, a sidebar, cards, buttons, forms. In React, each of those is its own component that you build once and reuse wherever you need it. This mirrors how we think about building things in the real world — you don't rebuild a wheel every time you need one."

SECTION 2: Single Page Applications (6 minutes)
[Slide: "Traditional Multi-Page Apps" — Diagram showing a browser making a request to a server, server returns a full HTML page, browser reloads for each new page]
"Before we talk about what React does, let's talk about what came before it so you understand the problem it solves.
In a traditional web application, every time you click a link or submit a form, your browser sends a request to the server. The server processes that, generates a whole new HTML page, and sends it back. Your browser throws away the old page and renders the new one. You see that white flash as the page reloads. This happens every single time you navigate.
[Slide: "Single Page Applications (SPAs)" — Diagram showing the initial load returning a shell HTML file + JavaScript bundle, then subsequent interactions handled by JavaScript in the browser, with small API calls for data]
A Single Page Application works completely differently. The browser loads one HTML file — basically just a shell — and one large JavaScript bundle. From that point on, when you click a link or interact with the page, JavaScript intercepts that action, updates the relevant part of the page, and potentially makes a small API call in the background to get just the data it needs. The browser never does a full page reload.
This is why apps like Gmail, Twitter, and Google Maps feel so fast and fluid — they behave more like desktop applications than traditional websites. The URL can still change, the back button still works, but React is managing all of that through JavaScript.
The trade-off is that the initial load can be heavier since the browser has to download all that JavaScript upfront. But once it's loaded, navigation is nearly instant because you're just swapping out parts of the page rather than doing a full round trip to the server every time.
React is one of the most popular tools for building SPAs, and understanding this model is essential for understanding why React makes the choices it does."

SECTION 3: The Virtual DOM and Reconciliation (10 minutes)
[Slide: "The Real DOM — The Problem" — A short description of what the DOM is, with a note that direct DOM manipulation is slow because it triggers reflows and repaints in the browser]
"To understand the Virtual DOM, you need to understand why direct DOM manipulation is expensive. The DOM — the Document Object Model — is the browser's internal representation of your page as a tree of objects. Every time you change something in the DOM, the browser has to do work: it recalculates styles, figures out the layout, and repaints the screen. For small changes this is fine. But if you're updating dozens of things rapidly — say, a live feed updating in real time — those operations add up and things start to feel sluggish.
[Slide: "The Virtual DOM" — Diagram showing three things: the Real DOM on the right, a Virtual DOM tree (described as a lightweight JavaScript object) on the left, and a React 'diffing' step in the middle]
React introduced the Virtual DOM to solve this. The Virtual DOM is not a browser feature — it's a concept React implements in JavaScript. It's essentially a lightweight copy of the real DOM, stored as a plain JavaScript object tree. It's fast to create and fast to compare because it's just JavaScript, not browser-rendered HTML.
Here's how the process works. When your application's data changes — say, a user clicks a button — React doesn't immediately touch the real DOM. Instead, it creates a new Virtual DOM tree representing what the UI should look like with the new data. Then it takes the old Virtual DOM tree and the new one, and compares them. This comparison process is called diffing.
[Slide: "Reconciliation" — Step-by-step flow: 1) State changes, 2) React creates new Virtual DOM, 3) React diffs old vs new Virtual DOM, 4) React calculates the minimum changes needed, 5) React applies only those changes to the real DOM]
Once React has identified the differences — maybe only one paragraph's text changed and one button's color changed — it applies only those specific changes to the real DOM. This whole process is called reconciliation.
The key insight is that React is batching and minimizing real DOM updates. Instead of you manually reaching into the DOM twenty times and triggering twenty repaints, React figures out the most efficient way to get the DOM from its current state to the desired state, and does it in as few operations as possible.
You don't have to write any of this yourself — React handles it automatically. But understanding it helps you write better React code. For example, it explains why React cares so much about keys when you render lists, which we'll get to shortly. Without a key, React can't efficiently figure out which list item changed — it has to assume everything changed. With a key, it can pinpoint exactly what's different."

SECTION 4: JSX Syntax and Rules (8 minutes)
[Slide: "What is JSX?" — A side-by-side of JSX code on the left and the equivalent React.createElement() call on the right, showing that JSX is syntactic sugar]
"JSX stands for JavaScript XML. It's a syntax extension that lets you write what looks like HTML directly inside your JavaScript. I want to be clear about something upfront: JSX is not HTML, and it's not a separate language. It's JavaScript with a different syntax. When your code gets compiled by a tool like Babel, every JSX expression gets transformed into a React.createElement() call under the hood.
So when you write <h1>Hello World</h1> in a component, what actually runs is React.createElement('h1', null, 'Hello World'). JSX is just a much more readable way to write this, and because we spend so much time thinking about UI structure, having it look like HTML makes our code more intuitive.
[Slide: "JSX Rules You Must Know" — A list of the key rules, each with a small code example]
Let me walk through the rules you absolutely need to know.
Rule 1: Every JSX expression must have one root element. You can't return two sibling elements without wrapping them. You either wrap them in a div or, if you don't want to add an extra DOM element, you use a Fragment — which looks like empty angle brackets, <> and </>.
Rule 2: All tags must be closed. In HTML, you can write <br> or <img src='...' > without a closing tag. In JSX, you must self-close them: <br />, <img src='...' />. If you forget this, you'll get a compile error.
Rule 3: Use className instead of class. Since JSX is JavaScript, and class is a reserved word in JavaScript, React uses className for CSS classes. Similarly, for becomes htmlFor on label elements.
Rule 4: JavaScript expressions go inside curly braces. Any time you want to embed a JavaScript value or expression in your JSX, you wrap it in {}. So <h1>{name}</h1> will render the value of the variable name. You can put any valid JavaScript expression inside curly braces — variables, arithmetic, ternary operators, function calls — but not if statements or for loops directly, because those are statements, not expressions.
Rule 5: Attributes are camelCase. HTML attributes like onclick and onchange become onClick and onChange in JSX. This is because JSX attribute names map to JavaScript DOM properties, which use camelCase.
Take a moment to internalize these rules. Most beginner bugs in React come down to violating one of them."

SECTION 5: Component Basics — Functional vs Class Components (7 minutes)
[Slide: "Components — The Building Blocks of React" — Analogy: Components are like LEGO bricks. Each one has a specific shape and purpose. You build complex things by combining simple ones.]
"A React component is a function or class that accepts some input — called props — and returns JSX that describes a piece of the UI. That's really all it is at its core.
Historically, React had two ways to write components: class components and functional components. I want to cover both because you'll encounter class components in older codebases, but I want to be upfront with you — functional components are the modern standard and everything you write going forward should use them.
[Slide: "Class Component" — A code example of a simple class component that extends React.Component with a render() method returning JSX. Label it: "Pre-2019 standard, still valid, but verbose"]
Class components use ES6 class syntax. You extend React.Component, and you must implement a render() method that returns your JSX. They have their own internal state managed through this.state and lifecycle methods like componentDidMount. The syntax is verbose, and the use of this can be confusing — especially for newer JavaScript developers.
[Slide: "Functional Component" — A clean code example of the same component as a function. Label it: "Modern standard since React 16.8 (2019)"]
Functional components are just JavaScript functions. They take props as an argument, and they return JSX. Before 2019, functional components couldn't manage their own state or respond to lifecycle events — that's why class components existed. But React 16.8 introduced Hooks, which gave functional components access to all of that. Overnight, the need for class components basically disappeared.
Functional components are simpler, easier to read, easier to test, and require less boilerplate. When you see a class component in a codebase today, it usually just means the code hasn't been updated. Both work — React still fully supports class components — but the direction the community and React itself has moved is firmly toward functional components and hooks."

SECTION 6: Creating Functional Components (5 minutes)
[Slide: "Anatomy of a Functional Component" — Annotated code example with labels pointing to: the function name (capitalized), the props parameter, the JSX return statement, the export statement]
"Let me walk through the anatomy of a functional component carefully because there are a few conventions that matter.
The function name must start with a capital letter. This is not just a convention — it's how React distinguishes between your custom components and standard HTML elements. If you write <div>, React knows that's an HTML element. If you write <MyComponent>, the capital M tells React to look for a function or class named MyComponent and call it.
Your function receives a single argument — props — which is a plain JavaScript object containing whatever data the parent passed in. Your function must return JSX or null. If you return null, nothing is rendered.
Always export your component. Typically you'll see export default ComponentName at the bottom, or export default function ComponentName inline with the function definition. You need to export it so other files can import and use it.
[Slide: Code showing a simple Greeting component, then showing it being used in another component like <Greeting /> — include the import statement at the top of the consuming file]
Here's a simple example. We have a Greeting component that returns an h1. In another file, we import it and use it just like an HTML tag. When React sees <Greeting />, it calls the Greeting function, gets back the JSX, and renders it. It's that straightforward."

SECTION 7: Props and Data Flow (7 minutes)
[Slide: "Props — Passing Data to Components" — Diagram showing a parent component passing data down to a child component via props. Label the arrow "one-way data flow"]
"Props — short for properties — are how you pass data from a parent component to a child component. They work similarly to HTML attributes. When you use a component, you can pass it any data you want by adding attributes to the JSX tag.
[Slide: Code example — a UserCard component that accepts name, age, and role as props, and a parent that renders <UserCard name="Sarah" age={28} role="Engineer" />]
Here we have a UserCard component. The parent passes three pieces of data: name, age, and role. Inside UserCard, those values are available on the props object as props.name, props.age, and props.role. Many developers use destructuring to make this cleaner — instead of writing props.name everywhere, you destructure at the top: function UserCard({ name, age, role }). The result is the same, just cleaner syntax.
Now here's the most important rule about props, and I want you to really hear this: props are read-only. A component must never modify its own props. This is called the one-way data flow principle — data flows down from parent to child, never the other way around.
This might seem restrictive, but it's one of the things that makes React applications predictable and easy to debug. When something goes wrong with a piece of data, you only ever need to look upward in the component tree to find the source of truth. Data has one origin and flows in one direction.
If a child component needs to communicate something back up to its parent — say, the user clicked a button — the pattern is for the parent to pass down a function as a prop, and the child calls that function. The data still originates in the parent. But we'll cover that more deeply when we talk about state and events."

SECTION 8: Lists and Keys (5 minutes)
[Slide: "Rendering Lists in React" — Code example showing an array of items being mapped to JSX elements, with and without a key attribute. Highlight the console warning that appears without keys.]
"In real applications you'll constantly need to render lists of things — a list of products, a feed of posts, a table of users. React makes this natural because JSX is just JavaScript, so you can use .map() to transform an array of data into an array of JSX elements.
The pattern looks like this: you have an array, you call .map() on it, and for each item you return a JSX element. React receives that array of elements and renders all of them.
But there's a critical requirement: every element in a list must have a key prop. The key must be a string or number that uniquely identifies that item within the list. React uses keys during reconciliation. When your list re-renders — maybe an item was added, removed, or reordered — React uses the keys to figure out exactly which items changed, rather than re-rendering the whole list from scratch.
[Slide: "Key Rules" — Three rules: 1) Keys must be unique among siblings (not globally), 2) Use stable, predictable values like database IDs — not array indexes when the list can change, 3) Keys are not passed as props — the component cannot access its own key]
The key must come from your data, not from the array index. Using the array index as a key is a common beginner mistake. It works fine for static lists that never change, but if items can be reordered or removed, using the index will cause React to associate the wrong element with the wrong key, leading to subtle bugs and performance issues. If your data has a unique ID from a database, use that. If not, you'll need to generate stable unique IDs for your items."

SECTION 9: Conditional Rendering (4 minutes)
[Slide: "Conditional Rendering" — Code showing three common patterns: if/else before the return, the ternary operator inline in JSX, and the && short-circuit operator]
"Conditional rendering is exactly what it sounds like — rendering different UI based on some condition. React doesn't have special templating syntax for this like some other frameworks do. Instead, you use regular JavaScript.
The cleanest approach for complex conditions is to write a normal if statement before your return and store the JSX you want to render in a variable. Then you use that variable in your return statement.
For simpler cases inline in JSX, you have two options. The ternary operator is great when you have an either-or situation: condition ? <ComponentA /> : <ComponentB />. It fits neatly inside JSX because it's an expression.
The logical AND operator && is useful when you either want to show something or show nothing: isLoggedIn && <UserPanel />. If isLoggedIn is true, React renders <UserPanel />. If it's false, it renders nothing. Just be careful with this pattern when your condition is a number — if the value is 0, React will actually render the digit 0 on screen rather than nothing, because 0 is a falsy value that JSX renders. Use a proper boolean comparison to be safe.
These three patterns will cover the vast majority of conditional rendering situations you'll encounter."

SECTION 10: Component Composition (4 minutes)
[Slide: "Composition over Inheritance" — A diagram showing a complex page broken down into a tree of nested components — Page > Header + Main + Footer, Main > Sidebar + ContentArea, ContentArea > multiple ArticleCard components]
"The last concept I want to cover today ties everything else together: composition. React is built around the idea of composing small, focused components together to build complex UIs — rather than using inheritance the way you might in classical object-oriented programming.
Every component you build should ideally do one thing well. A Button component just handles button rendering and clicks. A UserAvatar component handles displaying a user's image. A ProfileCard component might use both of those together to build something larger.
[Slide: "The children Prop" — Code showing a Card component that renders {props.children} inside a styled div, and usage showing <Card><p>Any content here</p></Card>]
One of the most powerful tools for composition is the special children prop. Every component automatically has access to props.children, which represents whatever JSX you put between the opening and closing tags of your component. This lets you build container or layout components that don't need to know what's inside them — they just provide the wrapper. A modal, a card, a sidebar — these are all great candidates for using children.
This approach — building complex UIs by combining simple components — is more flexible, more reusable, and easier to maintain than trying to build one monolithic component that handles everything."

CLOSING (4 minutes)
[Slide: "What We Covered Today" — A clean visual summary showing all 9 topic areas as a connected diagram or list]
"Let's do a quick recap. Today we covered why React exists and its core philosophy of declarative, component-based UI. We talked about Single Page Applications and how they differ from traditional multi-page apps. We went deep on the Virtual DOM and how React's reconciliation process makes updates efficient. We covered JSX — what it is and the rules you must follow. We distinguished functional from class components and made clear which one you should be writing. We looked at how to build functional components, how to pass data with props, how to render lists with proper keys, how to conditionally render UI, and how to compose components together.
[Slide: "Key Principles to Remember" — Five takeaways: "React is declarative — describe what, not how", "Data flows one way — parent to child via props", "Props are read-only", "Always use stable keys on list items", "Build small, composable components"]
If I had to give you five things to remember from today, it would be these: React is declarative — describe what the UI should look like, not how to change it. Data flows one direction. Props are read-only. Always use meaningful keys on lists. And build small components that you can combine.
In the next session we'll start looking at state — which is how React components manage their own internal data and how changes to that data trigger re-renders. Everything we did today will be the foundation for that.
Please take some time before next class to write a few components from scratch. Build a list that renders from an array. Try conditional rendering. The best way to internalize this is to type it out yourself."

SLIDE SUMMARY (Quick Reference)
Here is a condensed reference of every slide you need:
Slide 1 — Title slide with "React Fundamentals"
Slide 2 — "What is React?" with the four core descriptors and the library vs. framework distinction
Slide 3 — Declarative vs. Imperative side-by-side code comparison
Slide 4 — Traditional multi-page app request/response diagram
Slide 5 — SPA architecture diagram showing initial load and subsequent JS-driven updates
Slide 6 — "The Real DOM — The Problem" with a brief note on why direct manipulation is slow
Slide 7 — Virtual DOM diagram showing the three-way relationship between real DOM, virtual DOM, and React's diffing step
Slide 8 — Reconciliation step-by-step flow (5 steps)
Slide 9 — "What is JSX?" with the side-by-side JSX vs. React.createElement() comparison
Slide 10 — "JSX Rules You Must Know" with all five rules and short code snippets
Slide 11 — Class component code example, labeled as pre-2019 standard
Slide 12 — Functional component code example, labeled as modern standard
Slide 13 — Annotated anatomy of a functional component with callout labels
Slide 14 — Simple Greeting component shown being imported and used in another component
Slide 15 — One-way data flow diagram (parent passing props to child)
Slide 16 — UserCard example with props being passed and received, showing both props.name and destructured syntax
Slide 17 — List rendering with .map(), with and without keys, highlighting the console warning
Slide 18 — "Key Rules" — three rules about proper key usage
Slide 19 — "Conditional Rendering" — three patterns: if/else, ternary, and &&
Slide 20 — "Composition over Inheritance" — page broken into a tree of nested components
Slide 21 — children prop example showing a reusable container component
Slide 22 — Summary diagram of all topics covered
Slide 23 — "Key Principles to Remember" — the five takeawayscan you make hthis more complete. it seems everything has been condensed into fewer slides.5:16 PMReact Fundamentals — Complete 60-Minute Lecture Script
With Full Slide Descriptions

OPENING (5 minutes)
[Slide 1: Title Slide — "React Fundamentals: Building Modern User Interfaces" — Include your name, course name, and today's date. Clean, minimal design.]
[Slide 2: "Today's Learning Objectives" — A list of everything students will be able to do by the end of class: explain React's purpose and philosophy, describe how SPAs work, explain the Virtual DOM and reconciliation, write functional components with JSX, pass and receive props, render lists with proper keys, implement conditional rendering, and compose components together. Keep this visible for 60 seconds so students can read it.]
"Good morning everyone. Before we dive in, take a look at this slide — these are the specific things you should be able to do by the time we're done today. I want you to hold me accountable to this list. If we get to the end of class and something on here is still unclear, speak up.
Some of what we're going to talk about today you've been introduced to before. My goal isn't just to repeat that — it's to make sure everything connects. React has a handful of core ideas, and once you really understand those ideas, everything else falls into place. Today is about building that deep understanding.
Let's get into it."

SECTION 1: React Overview and Philosophy (10 minutes)
[Slide 3: "What is React?" — Four clean bullet points: "A JavaScript library for building user interfaces", "Created by Jordan Walke at Facebook, open-sourced in 2013", "Not a framework — it focuses on one thing: the UI layer", "Used by Facebook, Instagram, Airbnb, Netflix, Uber, and thousands more"]
"React is a JavaScript library. Not a framework — a library. The difference matters. A framework like Angular gives you a complete structure for your entire application — routing, HTTP requests, forms, everything. React intentionally doesn't do that. It focuses exclusively on building the user interface. For everything else — routing, data fetching, global state — you bring in separate tools. This gives you flexibility, but it also means there's more for you to learn and configure. React intentionally stays out of your way.
It was created at Facebook around 2011 by an engineer named Jordan Walke, and open-sourced in 2013. At the time, Facebook's codebase was getting extremely complex — not just in size but in the way different parts of the UI were interconnected. A single user action would need to update a notification badge, a message thread, a sidebar counter, and a newsfeed item all at once. Managing all of those updates manually, keeping them in sync, was becoming a serious engineering problem. React was the solution they built internally, and when they saw how well it worked, they shared it with the world.
[Slide 4: "The Core Problem React Solves" — A diagram showing a complex web of arrows between UI elements labeled things like "notification badge", "message count", "news feed", "sidebar" — illustrating how hard it is to manually keep UI in sync with data. Below it, a caption: "As UI complexity grows, manual DOM management becomes unmanageable."]
"This diagram represents what a lot of front-end code looked like before React. Every time data changed somewhere, you had to manually find every piece of UI that depended on that data and update it. These relationships grow exponentially as your app grows. React solved this by flipping the mental model entirely."
[Slide 5: "React's Core Philosophy — Declarative UI" — Two columns. Left column header: "Imperative (Vanilla JS)" with code that manually selects DOM elements and updates them. Right column header: "Declarative (React)" showing a component that simply describes what the UI should look like based on data. Below both columns: "Declarative: You describe the WHAT. React handles the HOW."]
"This is the single most important philosophical concept in React, so let's spend a minute on it. Imperative programming means you give the computer a sequence of instructions — do this, then do that, then do this other thing. You're describing the process. Declarative programming means you describe the desired outcome and let the system figure out the process.
When you write React, you write components that describe what the UI should look like given a particular set of data. If the data changes, React automatically figures out what needs to update in the UI. You don't write the update logic — React handles it. This is enormously powerful because it means your UI is always a direct reflection of your data. There's no risk of the two getting out of sync.
[Slide 6: "React's Core Philosophy — Component-Based Architecture" — A visual of a finished webpage on the left, and on the right the same webpage with colored boxes drawn around each distinct section — navbar, hero, feature cards, footer — each labeled with a component name. Caption: "Complex UIs are built from small, self-contained, reusable pieces."]
"The second core idea is that everything in React is a component. A component is a self-contained piece of UI that manages its own structure and — eventually — its own data. Think about a navigation bar. You build it once as a Navbar component. Then anywhere in your application that needs a navigation bar, you just drop in <Navbar />. You don't rewrite it. You don't copy and paste HTML. You reuse the component.
This mirrors how we build things in the real world. A car manufacturer doesn't design a new steering wheel for every car model from scratch. They design one good steering wheel and put it in multiple vehicles. Components work the same way.
[Slide 7: "React's Core Philosophy — Unidirectional Data Flow" — A simple top-to-bottom diagram showing data starting at a top-level component and flowing down through child components via arrows labeled "props". A caption below: "Data always flows down. Never up. Never sideways."]
"The third foundational idea — which we'll get into more deeply when we talk about props — is that data in React flows in one direction: downward. Data lives in a parent component and gets passed down to children. Children never push data back up to parents directly. This one-way flow makes your application predictable. When a bug appears, you know exactly where to look — upward along the data flow until you find where something is wrong.
These three ideas — declarative UI, component-based architecture, and unidirectional data flow — are the philosophical DNA of React. Everything else we talk about today flows from these."

SECTION 2: Single Page Applications (8 minutes)
[Slide 8: "How Traditional Web Apps Work" — A step-by-step diagram: 1) User clicks a link, 2) Browser sends a GET request to the server, 3) Server processes the request and generates a full HTML page, 4) Server sends the full HTML back, 5) Browser discards the old page and renders the new one. Label across the bottom: "Every navigation = full page reload = white flash = slow"]
"Let's talk about how web applications worked before SPAs were common, because understanding the old model makes the new one much clearer.
In a traditional multi-page application, every interaction that needs new content requires a full round trip to the server. You click a link. Your browser sends a request. The server generates a brand new HTML page — the entire page — and sends it back. The browser throws away everything it had, parses the new HTML, downloads any new CSS and JavaScript it needs, and renders the page fresh. This is what causes that brief white flash you see when navigating some websites. Every page transition involves this entire cycle.
This model works fine and it's not inherently bad — it's still used everywhere. But it has limitations. It's slow for highly interactive applications, it interrupts the user experience, and maintaining application state across page loads requires extra work.
[Slide 9: "How Single Page Applications Work" — A two-part diagram. Top part: Initial load — browser requests the app, server returns one HTML file + one JavaScript bundle. Label this "Happens once". Bottom part: After initial load — user interactions are handled by JavaScript, small API calls fetch only data, and React updates only the relevant parts of the UI. Label this "Happens on every navigation". Note at bottom: "The URL can still change. The back button still works. But there's no full reload."]
"A Single Page Application works completely differently. On the very first visit, the browser makes one request and downloads one HTML file — which is basically just an empty shell with a div that says something like id='root' — and a JavaScript bundle that contains your entire React application. That's it. That's the only full page load that ever happens.
From that point on, JavaScript takes over completely. When you click a navigation link, React intercepts that click, swaps out the content in the page, maybe makes a small API call to get the specific data it needs, and re-renders the relevant section. The browser never reloads. The URL updates. The back button works. But you're never doing that full round trip to get a whole new HTML page.
[Slide 10: "SPAs — The Trade-offs" — Two columns. Pro column: "Fast navigation after initial load", "Feels like a native app", "Reduced server load after startup", "Smooth transitions and animations". Con column: "Larger initial download (the JS bundle)", "More complex tooling and configuration", "SEO requires extra work (server-side rendering)", "JavaScript must be enabled"]
"Like any architectural decision, SPAs involve trade-offs. The experience after the initial load is excellent — fast, fluid, app-like. But that initial load can be heavier because you're downloading all the JavaScript upfront. Search engine optimization is also more complicated because search engine crawlers traditionally expect fully-formed HTML, not a shell that JavaScript fills in later. Tools like Next.js solve this with server-side rendering, but that's a future topic.
For most of what you'll build as you learn React, you'll be building SPAs. Understanding this model tells you why React is structured the way it is — it was designed to manage the UI of these kinds of applications."

SECTION 3: The Virtual DOM and Reconciliation (12 minutes)
[Slide 11: "What is the DOM?" — A brief refresher. On the left: a snippet of HTML. On the right: a tree diagram of the same HTML as DOM nodes — document > html > body > div > h1 + p. Caption: "The DOM is the browser's live, in-memory representation of your page as a tree of objects."]
"Before we can talk about the Virtual DOM, let's make sure we're all clear on what the real DOM is. When a browser loads an HTML file, it parses that HTML and creates a tree of objects in memory — this is the Document Object Model, the DOM. Every tag in your HTML becomes a node in this tree. JavaScript can interact with this tree to read information from it or change it, which is what creates dynamic web pages.
[Slide 12: "The Problem With Direct DOM Manipulation" — A text-heavy slide explaining the performance cost. Key points: "Accessing the DOM is a 'crossing of worlds' between the JavaScript engine and the browser's rendering engine", "Every DOM change can trigger a reflow (layout recalculation) and repaint", "These operations are expensive at scale", "If you update 50 elements in a loop, you could trigger 50 separate reflows". A simple diagram showing the JavaScript engine and the rendering engine as two separate boxes with a costly bridge between them.]
"Here's why direct DOM manipulation is slow at scale. JavaScript runs in the browser's JavaScript engine — V8 in Chrome, for example. The DOM lives in the browser's rendering engine. These are separate systems. Every time your JavaScript reaches out and touches the DOM, it's crossing a bridge between two worlds, and that bridge has a cost.
Beyond that, when you change the DOM — adding an element, changing a class, updating text — the browser often has to recalculate the layout of the entire page, figure out what changed visually, and repaint the affected area. For one change, this is fine. For dozens of changes happening rapidly — say, a real-time data dashboard refreshing every few hundred milliseconds — these costs stack up and the UI becomes noticeably sluggish.
[Slide 13: "The Virtual DOM — The Concept" — A three-column diagram. Column 1: "Your React Components" with a simple component tree. Column 2: "Virtual DOM" with a note: "A lightweight JavaScript object representation of the UI tree. Lives entirely in memory. No browser APIs. Extremely fast to create and compare." Column 3: "Real DOM" with a note: "The actual browser DOM. Slow to update. Triggers reflows and repaints." An arrow from Column 1 to Column 2 labeled "React creates this", and an arrow from Column 2 to Column 3 labeled "React syncs this as minimally as possible."]
"React's answer to this problem is the Virtual DOM. The Virtual DOM is not a browser technology — it's not something browsers invented. It's a concept that React implements entirely in JavaScript. The Virtual DOM is simply a plain JavaScript object that mirrors the structure of the real DOM. It has nodes, children, attributes — all of it — but it's just data. There are no browser APIs involved, no rendering engine interaction. It's pure JavaScript objects, which means it's incredibly fast to create and to traverse.
[Slide 14: "How the Virtual DOM Works — Step by Step" — A numbered flow diagram: Step 1: "Your application's data (state or props) changes" → Step 2: "React re-runs your component functions and produces a new Virtual DOM tree" → Step 3: "React compares the new Virtual DOM tree against the previous Virtual DOM tree — this is called DIFFING" → Step 4: "React calculates the minimal set of changes needed to bring the old tree in line with the new tree" → Step 5: "React applies only those specific changes to the real DOM" → Step 6: "The browser updates only the affected areas." A note at the bottom: "This entire process is called RECONCILIATION."]
"Here's the step-by-step process. When your data changes — say, a user's name changes — React doesn't immediately go to the real DOM. First, it re-runs your component functions with the new data and builds a brand new Virtual DOM tree in memory. Then it takes that new tree and compares it to the previous Virtual DOM tree. This comparison is called diffing. React walks through both trees simultaneously and notes every place where they differ.
Once it has that complete list of differences, React calculates the most efficient way to update the real DOM to reflect those changes. Maybe out of a tree with five hundred nodes, only three things actually changed. React applies only those three changes to the real DOM. This whole orchestration process — detecting changes, diffing, and applying the minimum necessary updates — is called reconciliation.
[Slide 15: "Diffing — How React Compares Trees" — Three sub-diagrams showing the three main scenarios React handles during diffing: 1) Same element type at the same position — React updates just the changed attributes. 2) Different element type at the same position — React tears down the old subtree entirely and builds a new one. 3) A list of elements — React uses keys to match old items to new items, identifying insertions, deletions, and moves.]
"The diffing algorithm makes a few key assumptions to keep things fast. First, if two elements are the same type — say both are div elements — React assumes they represent the same thing and just checks what attributes or children changed. It updates only what's different. Second, if the element type changes at the same position — say a div becomes a span — React doesn't try to salvage the old element. It tears down the entire subtree and builds a fresh one. Third, and this is where keys come in, when React is diffing a list of child elements, it needs a way to match up items between the old list and the new list. Without keys, it can only compare by position — item 1 vs item 1, item 2 vs item 2. With keys, it can say 'this item with key 42 was here before, and now it's in a different position — I can move it instead of destroying and recreating it.'
[Slide 16: "Why This Matters For You As a Developer" — Three practical takeaways: 1) "You never manually manipulate the DOM in React — React does it for you, optimally." 2) "Keys on lists are not optional decoration — they're essential information that React needs to reconcile efficiently." 3) "Understanding reconciliation helps you avoid unnecessary re-renders as your apps grow more complex."]
"The practical takeaway here is that React's Virtual DOM and reconciliation engine are doing a lot of sophisticated work on your behalf. Your job is to describe what the UI should look like. React's job is to figure out how to get the real DOM there as efficiently as possible. You don't write the update logic. You don't track what changed. You just describe the desired state, and React handles the rest."

SECTION 4: JSX Syntax and Rules (10 minutes)
[Slide 17: "What is JSX?" — A clean definition slide. "JSX stands for JavaScript XML. It is a syntax extension to JavaScript that allows you to write HTML-like markup directly inside your JavaScript code." Below the definition, a side-by-side. Left side: JSX code showing a simple component with a div, h1, and paragraph. Right side: the identical code written using nested React.createElement() calls. A bold caption between them: "JSX is syntactic sugar. Babel compiles it into React.createElement() calls at build time."]
"JSX is one of the things that surprises people when they first see React. It looks like you're mixing HTML directly into your JavaScript, which goes against everything you were probably told about separation of concerns. But JSX isn't really HTML — it's a syntax extension that gives you a more readable way to write something you'd otherwise write as deeply nested function calls.
Look at the right side of this slide. That's what your code actually becomes after it's compiled. It's completely valid JavaScript — just a series of React.createElement() calls, where each call creates a node in the Virtual DOM. Writing your UI this way directly would be technically correct but nearly unreadable. JSX gives you the familiar structure of HTML while still being pure JavaScript. The compilation step is handled automatically by tools like Babel and Vite, so you never have to think about it.
[Slide 18: "JSX Rule 1 — One Root Element" — Left side: broken code showing a component trying to return two sibling divs without a wrapper (with a red X). Right side: two solutions — wrapping in a div (with a green checkmark), and using a Fragment <>...</> (with a green checkmark). Explanation: "Fragments let you group elements without adding extra nodes to the DOM."]
"The first rule: every JSX expression must return a single root element. Your component's return statement can only return one thing. You cannot return two sibling elements side by side — JSX doesn't allow it, and it wouldn't map to a valid React.createElement() call anyway since a function can only return one value.
Your options are: wrap your elements in a container div, or use a Fragment. A Fragment is represented by empty angle brackets — <> and </> — and it tells React 'group these elements together, but don't add any actual DOM node for the wrapper.' This keeps your DOM cleaner when you don't actually need an extra div there.
[Slide 19: "JSX Rule 2 — All Tags Must Be Closed" — Left side: HTML that is valid but would break JSX — <br>, <img src="...">, <input type="text">. Right side: the correct JSX versions — <br />, <img src="..." />, <input type="text" />. Caption: "If a tag has no children, self-close it."]
"Rule two: every tag must be explicitly closed. In HTML, certain elements are void elements — they don't take children and don't need a closing tag. br, img, input — these are all valid in HTML without a closing slash. JSX does not allow this. Every tag must be closed, either with a closing tag or with a self-closing slash before the angle bracket. If you forget, you'll get a syntax error at compile time.
[Slide 20: "JSX Rule 3 — className and htmlFor" — A table with two columns. Left column: "HTML Attribute". Right column: "JSX Equivalent". Rows: class → className, for → htmlFor, tabindex → tabIndex, readonly → readOnly. A note below: "JSX attribute names map to the DOM property names, which use camelCase JavaScript conventions."]
"Rule three: several attribute names are different in JSX compared to HTML. The most important one is class. In HTML you write class='container'. In JSX you write className='container'. The reason is that class is a reserved keyword in JavaScript — it's used to define ES6 classes. Since JSX compiles to JavaScript, you can't use reserved words as attribute names. React uses className instead, which maps to the className DOM property.
Similarly, the HTML for attribute on labels becomes htmlFor in JSX, because for is also a reserved word in JavaScript. There are a handful of other attributes like this, but className and htmlFor are the ones you'll run into constantly.
[Slide 21: "JSX Rule 4 — JavaScript Expressions in Curly Braces" — Multiple code examples showing: a variable being rendered {name}, arithmetic {price * quantity}, a function call {formatDate(date)}, and a ternary expression {isLoggedIn ? 'Welcome' : 'Please log in'}. A note: "You can embed any JavaScript EXPRESSION. Not statements. Expressions produce a value. Statements do not."]
"Rule four: whenever you want to embed JavaScript inside your JSX, you wrap it in curly braces. Curly braces are your escape hatch from JSX back into JavaScript. You can put any valid JavaScript expression inside — a variable reference, arithmetic, a function call, a ternary operator, a template literal. The key word is expression — something that produces a value. You cannot put JavaScript statements like if statements or for loops directly inside JSX because those don't produce values. For conditionals and loops you'll use the patterns we talk about later.
[Slide 22: "JSX Rule 5 — Event Handlers and Attributes are camelCase" — A table showing: onclick → onClick, onchange → onChange, onsubmit → onSubmit, onkeydown → onKeyDown, onfocus → onFocus. A note: "In JSX, you pass functions as event handlers, not strings." Show the difference: HTML: onclick='handleClick()' vs JSX: onClick={handleClick}. Note the absence of parentheses on the JSX side.]
"Rule five: all HTML event attributes become camelCase in JSX. onclick becomes onClick, onchange becomes onChange, and so on. But there's something else here that catches beginners off guard: in HTML, event handlers are strings containing JavaScript code — onclick='doSomething()'. In JSX, you pass an actual JavaScript function reference — onClick={handleClick} — notice there are no parentheses. You're not calling the function; you're passing a reference to it so React can call it when the event fires. If you write onClick={handleClick()}, you're calling the function immediately when the component renders, which is almost never what you want.
[Slide 23: "JSX — Styling" — Two approaches shown with code. Left: Inline styles using the style prop, noting that style takes a JavaScript object with camelCase property names: style={{ backgroundColor: 'blue', fontSize: '16px' }}. Right: className approach using external CSS or CSS modules. Note: "Inline styles use camelCase JavaScript property names, not hyphenated CSS names. background-color becomes backgroundColor."]
"One more thing on JSX — styling. You have a few ways to apply styles. The style prop accepts a JavaScript object — not a CSS string. The property names in that object are camelCase JavaScript versions of CSS properties: background-color becomes backgroundColor, font-size becomes fontSize. Notice the double curly braces when using inline styles — the outer braces are the JSX expression delimiter, and the inner braces are the JavaScript object literal.
More commonly you'll use the className prop to apply CSS class names from an external stylesheet. Both approaches are valid and you'll use both in practice."

SECTION 5: Functional vs Class Components (8 minutes)
[Slide 24: "Components — The Core Unit of React" — A conceptual definition: "A component is a self-contained, reusable piece of UI. It accepts inputs (called props), manages its own logic, and returns JSX describing what should be rendered." Below that, an analogy: "Think of components like custom HTML tags that you define yourself."]
"Let's talk about components in depth. A component is the fundamental building block of any React application. At its simplest, a component is just a piece of your UI that you've packaged into a reusable unit. It takes in data, does something with it, and returns a description of what should appear on screen.
A useful mental model is to think of components as custom HTML tags. HTML gives you div, p, h1, button. React lets you define your own — UserProfile, ProductCard, NavigationBar. You use them exactly the same way you'd use an HTML tag, and React knows to look for your component definition and render it.
[Slide 25: "Class Components — The Old Way" — A full, properly annotated code example of a class component. It should: extend React.Component, have a constructor with super(props), have this.state initialized, have a render() method that returns JSX, and use this.props and this.state inside render(). Each part should be labeled with an annotation arrow: "Must extend React.Component", "Must have a render() method", "Return JSX from render()", "Access props via this.props", "Internal state via this.state"]
"Before 2019, there were two types of components in React: class components and functional components. Class components were the only way to have a component manage its own state or respond to lifecycle events — things like 'do something when this component mounts on the screen' or 'clean up when this component is removed.'
A class component uses ES6 class syntax. You extend React.Component, you must implement a render() method, and that render method must return JSX. State is initialized in the constructor and accessed as this.state. Props are accessed as this.props. The this keyword is central to everything, and as anyone who's worked with JavaScript's this can tell you, it's a frequent source of confusion and bugs — especially around event handlers where this binding has to be managed manually.
[Slide 26: "Functional Components — The Modern Standard" — The exact same UI functionality as the previous slide's class component, rewritten as a clean functional component using hooks for state. Label: "Introduced React Hooks in 16.8 (February 2019)". Annotations: "Just a regular JavaScript function", "Props passed as a parameter", "State via useState hook", "No this keyword anywhere", "Much less boilerplate"]
"Everything changed in February 2019 when React 16.8 introduced Hooks. Hooks are functions that let you 'hook into' React features — like state and lifecycle — from inside a functional component. Overnight, the main reasons to use class components disappeared.
A functional component is exactly what it sounds like — a plain JavaScript function. It receives props as an argument, and it returns JSX. No classes, no constructors, no this. State is handled through the useState hook. Side effects are handled through useEffect. The code is shorter, cleaner, and far easier to understand.
[Slide 27: "Class vs Functional — A Direct Comparison" — A two-column comparison table. Rows: Syntax (Class keyword vs Function keyword), State (this.setState vs useState hook), Lifecycle (componentDidMount etc vs useEffect hook), this keyword (Required and confusing vs Not needed), Code length (More verbose vs More concise), Current status (Legacy — still supported vs Modern standard — use this), Testing (More complex vs Simpler). Bottom of slide: "You WILL encounter class components in real codebases. You should understand them. You should write functional components."]
"Here's a direct comparison. I want to be completely clear: you should write functional components for all new code. The React team themselves recommends this. All modern React documentation is written using functional components and hooks. Class components are not going away — React will support them indefinitely for backward compatibility — but they represent the old way of doing things.
When you join a team or inherit an existing codebase, you will almost certainly encounter class components. Understanding how to read them is important. But when you write new code, write functional components."

SECTION 6: Creating Functional Components (7 minutes)
[Slide 28: "The Rules of Functional Components" — A list with explanations: 1) Function name MUST start with a capital letter — explains why (React uses this to distinguish custom components from HTML elements), 2) Must return JSX or null, 3) Must be a pure function with respect to props (same props = same output), 4) Must be exported to be used in other files. Each rule has a brief code snippet showing correct and incorrect examples.]
"Let's get into the specifics of writing a functional component correctly.
The capital letter rule is non-negotiable. If you write function myComponent() with a lowercase m, and you use it as <myComponent />, React will treat it as an unknown HTML element — it'll try to render it as a literal HTML tag named 'mycomponent', which doesn't exist. React distinguishes custom components from built-in HTML elements entirely based on the first letter's case. Capitalize your component names. Always.
[Slide 29: "Anatomy of a Functional Component — Annotated" — A complete, annotated code example of a well-formed functional component. It should include: the import statement at the top, the function declaration with a capitalized name, the props parameter (shown both as props and with destructuring), a few lines of logic before the return, the JSX return with a single root element, and the export default at the bottom. Each section is annotated with a labeled arrow.]
"Let's look at the anatomy of a component from top to bottom. At the very top, you have your import statements — any React imports you need, any child components you use, any CSS, any utilities. In modern React you often don't even need to import React itself in every file anymore, but you'll still import hooks and other things.
Then your function declaration. Name it clearly — ProductCard, not Card1. Descriptive names make your codebase navigable.
Inside the function, you can write any JavaScript you need before the return statement — calculations, variable declarations, conditional logic, anything. The return statement contains your JSX. Remember the one root element rule.
At the bottom, export default makes the component available for import in other files. Without this, your component is a function defined in a file that no one can use.
[Slide 30: "Props Destructuring — Two Equivalent Styles" — Side by side code. Left: using props.name, props.email, props.role throughout the component. Right: destructuring at the function parameter level — function UserCard({ name, email, role }) — and then using name, email, role directly. Both produce identical results. Caption: "Destructuring is preferred in practice — it's cleaner and makes the expected props explicit."]
"Both of these styles are completely valid and produce identical results. The destructured version on the right is what you'll see most often in professional code because it makes the component's expected inputs immediately visible at the top of the function definition. You can glance at the signature and know exactly what props this component uses. It's also less repetitive to write name than props.name everywhere."
[Slide 31: "A Complete Example — Build and Use a Component" — Three code blocks. Block 1: A WelcomeBanner component that accepts username and message as props and renders them in a styled div. Block 2: The file structure showing how to export it. Block 3: Another component file that imports WelcomeBanner and uses it with specific prop values. The import statement should be clearly visible.]
"Here's a complete end-to-end example. We define a WelcomeBanner component, we export it, and in a separate file we import it and use it just like an HTML tag. Notice the import path — we're importing from a relative path to the file where the component is defined. When you use <WelcomeBanner username='Sarah' message='Welcome back!' />, React calls the WelcomeBanner function with { username: 'Sarah', message: 'Welcome back!' } as the props argument, gets back JSX, and renders it."

SECTION 7: Props and Data Flow (8 minutes)
[Slide 32: "What Are Props?" — A clean definition: "Props (short for properties) are the mechanism for passing data from a parent component to a child component. They are passed as attributes in JSX and received as a plain JavaScript object inside the component." Below: an analogy — "Props are like arguments to a function. You pass data in, the function uses it to produce output."]
"Props are React's primary way of moving data around your application. When you use a component, you pass it data by adding attributes to the JSX tag — exactly like you'd add attributes to an HTML element. That data arrives inside the component as a plain JavaScript object called props.
The function analogy is a good one. When you call a function, you pass arguments. When you render a component, you pass props. The component uses those props to determine what to render. Different prop values produce different UI output — but the component's logic stays the same.
[Slide 33: "Passing Props — All the Types You Can Pass" — A code example showing a parent component passing multiple types of data as props to a child: a string (name="Sarah"), a number (age={28} — note the curly braces for non-string values), a boolean (isAdmin={true} or simply isAdmin), an array (scores={[95, 87, 92]}), an object (address={{ city: 'Austin', state: 'TX' }}), and a function (onUpdate={handleUpdate}). A note: "Strings can use quotes directly. Everything else uses curly braces."]
"You can pass any JavaScript value as a prop — strings, numbers, booleans, arrays, objects, and even functions. The syntax difference to notice: string values can use regular quote marks, but everything else needs curly braces because everything else is a JavaScript expression. name='Sarah' is a string. age={28} is a number. scores={[95, 87, 92]} is an array. The curly braces are what tell JSX 'evaluate this as JavaScript, not a string.'
[Slide 34: "Receiving and Using Props" — The matching child component code from the previous slide's parent. Show both versions: first with props.name, props.age, etc., then with destructuring in the function signature. Show the rendered output. Annotate clearly what each prop value produces in the UI.]
"On the receiving end, your component gets all those values bundled together in the props object. If you access props.name, you get 'Sarah'. props.age gives you 28. With destructuring, you pull those values out at the top and use them directly.
[Slide 35: "The Golden Rule of Props — They Are Read-Only" — Large, prominent text: "A component must NEVER modify its own props." Below that, a code example showing what NOT to do — a component that tries to reassign props.count = props.count + 1 with a red X. Then an explanation: "Props belong to the parent. The parent is the source of truth. If a child needs to signal that data should change, it asks the parent to change it — via a callback function passed as a prop."]
"This is a rule I want you to genuinely internalize, not just memorize for a quiz. Props are read-only. A component must never modify its own props. The data belongs to the parent. The child can read it and display it, but it cannot change it.
Why? Because React's predictability depends on data having a single source of truth. If children could modify props arbitrarily, you'd have no idea where data was being changed, and debugging would become a nightmare. One-way data flow means there's only one place any given piece of data lives, and only one place it can be changed.
[Slide 36: "One-Way Data Flow — Why It Matters" — A diagram showing a component tree with data flowing down from a top-level App component through several levels. Arrows are all pointing downward, labeled "props". A separate smaller diagram showing the question: "What if a child needs to tell a parent something?" — Answer shown: the parent passes a function as a prop, the child calls that function. Label this pattern: "Lifting state up — you'll learn this when we cover state."]
"The one-way data flow is one of React's most important characteristics. All data flows downward through the component tree via props. When something at the bottom of the tree needs to affect something at the top — say, a button in a child component needs to update data in the parent — the pattern is for the parent to pass a function down as a prop. The child calls that function when the event happens. The function lives in the parent and changes the parent's state. React re-renders the parent and passes new props down. The data still has one source of truth, and the flow is still one direction. We'll build this pattern out fully when we get to state management."

SECTION 8: Lists and Keys (8 minutes)
[Slide 37: "Rendering Lists in React" — A code example showing an array of strings being mapped to <li> elements using .map(). Show the complete picture: the array of data, the .map() call inside JSX, and the rendered output. Highlight that .map() returns a new array of JSX elements, and React knows how to render an array of elements.]
"In real applications you'll render lists constantly — products, users, posts, messages, search results. React doesn't have a special loop directive like some other frameworks. Instead, you use standard JavaScript array methods, most commonly .map().
The pattern is natural: you have an array of data, you call .map() on it, and for each item you return a JSX element. React understands that if you return an array of JSX elements, it should render all of them. The result is a list of elements, each one generated from your data.
[Slide 38: "The Key Prop — What It Is" — A code example showing the same list from the previous slide, this time with a key prop on each element. Use key={item.id} where possible. Alongside, show the browser console warning that appears when keys are missing: "Warning: Each child in a list should have a unique 'key' prop." Explain what a key is: "A key is a special string or number attribute you provide to help React identify which items in a list have changed, been added, or been removed."]
"When you render a list in React, every element in that list must have a key prop. If you forget it, React will still render the list — you won't get a crash — but you'll see a warning in the browser console, and more importantly, React's reconciliation process becomes less efficient and potentially incorrect.
[Slide 39: "Why Keys Matter — The Reconciliation Problem" — A diagram showing two versions of a list. Version 1 (before): items A, B, C. Version 2 (after): items A, C (B was removed). Left side: without keys — React compares by position and thinks item at position 2 changed from B to C, and item at position 3 was deleted. Right side: with keys — React can identify by key that item B was removed and items A and C are unchanged. Caption: "Without keys, React may re-render perfectly unchanged elements unnecessarily. With keys, React surgically removes only what's gone."]
"Here's why keys matter for reconciliation. Imagine you have a list of three items — A, B, and C — and then B gets removed. Without keys, React compares the new list against the old list by position. Position 1: A to A, no change. Position 2: B to C — React thinks the second item changed, so it updates it. Position 3: the old C is now missing — React deletes it. React did two DOM operations when it should have done one.
With keys, React can match items by their identity rather than their position. It sees that item A with key 'a' is still there, item B with key 'b' is gone, and item C with key 'c' is still there. It performs exactly one operation: remove item B. This is the right behavior, it's faster, and it prevents visual glitches — especially in lists that contain things like form inputs where re-rendering can accidentally reset state.
[Slide 40: "Key Rules — What Makes a Good Key" — Four rules with explanations and code examples: 1) Keys must be unique among siblings — not globally unique, just unique within the same list. 2) Keys should be stable — they should not change between renders. 3) Keys should come from your data, ideally a database ID. 4) DO NOT use the array index as a key when the list can be reordered or filtered. A code comparison: bad key (array index key={index}) vs good key (stable ID key={user.id})]
"The key must be unique within its list, but doesn't need to be globally unique across your whole application. Two different lists can have an item with the same key without any problem.
The key must be stable. It should be the same value every time that item renders. This is why you should not use the array index as your key unless your list is completely static and will never be reordered, filtered, or have items added or removed. If you remove an item from the middle of a list that uses index-based keys, every item after the removed one shifts its index — now their keys are all different from what they were before, and React thinks they all changed, which defeats the entire purpose.
Use an ID from your data. If your data comes from a database, use the database row ID. If you're generating data in the frontend, use a UUID or some other stable identifier that you generate once when the item is created and never change.
[Slide 41: "Keys on Custom Components vs HTML Elements" — Code showing that the key goes on the outermost element in the map, whether that's an HTML element like <li key={item.id}> or a custom component like <ProductCard key={product.id} product={product} />. A note: "The key prop is consumed by React for its own reconciliation purposes. It is NOT passed through to the component as a prop. You cannot access props.key inside your component."]
"One final note: put the key on the outermost element returned by your .map() call. If you're mapping to a custom component, the key goes on the component tag, not buried inside it. Also important: the key prop is special. React intercepts it and uses it internally. It is not passed through to the component — if you try to access props.key inside a component, you'll get undefined. If you actually need that ID value inside the component, pass it as a separate prop with a different name."

SECTION 9: Conditional Rendering (6 minutes)
[Slide 42: "What is Conditional Rendering?" — A definition: "Rendering different UI based on some condition. React has no special template syntax for this — you use regular JavaScript." Three method names listed as a preview: "1. if/else before the return", "2. Ternary operator inline", "3. Logical AND (&&) operator"]
"Conditional rendering is one of the most common things you'll do in React. Almost every real UI has elements that appear or disappear based on data — a loading spinner that shows while data is fetching, an error message that shows if something failed, a user menu that shows if someone is logged in. React doesn't have template directives like v-if or ngIf for this. You use standard JavaScript.
[Slide 43: "Method 1 — if/else Before the Return" — A code example showing a component that determines what to render using an if/else before the return statement. Store JSX in a variable, then return the variable. Works well for complex conditions with multiple possible outcomes. Show a component that renders different content based on a status prop with three possible values: 'loading', 'error', and 'success'.]
"The cleanest approach for anything more than a simple binary condition is to write your conditional logic before the return statement using normal if blocks. You store the result in a variable and return the variable. This keeps your JSX clean and puts all your decision logic in one place at the top of the function. It's the most readable approach when you have three or more possible outcomes.
[Slide 44: "Method 2 — Ternary Operator" — A code example showing the ternary operator used inline inside JSX to conditionally render one of two things: {isLoggedIn ? <UserMenu /> : <LoginButton />}. Also show it being used to conditionally render different text or different className values. Note: "Best for binary either/or choices. Avoid nesting ternaries — they become unreadable fast."]
"The ternary operator is perfect for binary either-or situations inside your JSX. The syntax is condition ? valueIfTrue : valueIfFalse. Since it's an expression, it works inside curly braces in JSX. You can use it to choose between two components, two strings, two class names — anything.
A word of caution: don't nest ternaries. condition1 ? (condition2 ? a : b) : c becomes very hard to read very quickly. If you find yourself nesting, go back to method one and write explicit if statements.
[Slide 45: "Method 3 — Logical AND (&&)" — A code example showing the && pattern: {isAdmin && <AdminPanel />}. Explain how it works: if the left side is truthy, JavaScript returns the right side. If falsy, it returns the left side — and React doesn't render false. Then show the GOTCHA: {itemCount && <ItemList />} — if itemCount is 0, React renders the number 0, not nothing. Show the fix: {itemCount > 0 && <ItemList />}.]
"The logical AND operator gives you a shorthand for 'show this thing, or show nothing.' In JavaScript, A && B returns B if A is truthy, and returns A if A is falsy. React renders false, null, and undefined as nothing — they produce no output. So {isAdmin && <AdminPanel />} renders the AdminPanel when isAdmin is true, and renders nothing when it's false.
Here's a trap that catches almost every React beginner at least once: if your condition is a number that could be zero, this pattern will render the number zero on screen. {itemCount && <ItemList />} — if itemCount is zero, JavaScript evaluates 0 && <ItemList /> and returns 0. React sees the number 0 and renders it. You'll have a mysterious 0 appearing on your page. The fix is simple: use a proper boolean comparison — {itemCount > 0 && <ItemList />} — so your condition is always a true boolean.
[Slide 46: "Conditional Rendering — Choosing the Right Method" — A simple decision flowchart: "More than 2 possible outcomes?" → Yes → "Use if/else before the return". "Exactly 2 outcomes, need to choose between them?" → "Use ternary". "Show something or show nothing?" → "Use &&, but beware the 0 gotcha".]
"Here's how to decide which method to use. For complex conditions with three or more outcomes, use if/else. For exactly two possibilities where you're choosing between them, use the ternary. For 'show this thing or nothing', use && — and remember the zero gotcha."

SECTION 10: Component Composition (4 minutes)
[Slide 47: "Composition — Building Complex UIs From Simple Pieces" — A visual decomposition of a complex page. Show a fully designed page mockup on the left. On the right, show the same page broken down into a nested component tree: App > Header + Main + Footer, Main > Sidebar + Feed, Feed > multiple PostCard components, PostCard > Avatar + PostContent + LikeButton. Caption: "Composition is how React applications scale. Small components combine to create complex UIs."]
"Composition is the idea that you build complex things by combining simple ones. This is how React applications are structured in practice. You have small, focused components at the leaves of the tree — a button, an avatar image, a timestamp. You combine those into medium-level components — a post card, a navigation item. You combine those into larger sections — a feed, a sidebar. And those combine into your pages.
Each component knows how to do one thing well. And because they're self-contained, you can reuse them anywhere, test them in isolation, and change one without breaking others.
[Slide 48: "The children Prop" — Code showing a reusable Card container component that renders {props.children} inside a styled div. Then show the usage — <Card><h2>Title</h2><p>Some content</p></Card> — and the rendered result. Explain: "Whatever you put between the opening and closing tags of a component becomes props.children inside that component." Second example: a Modal component that uses children to display arbitrary content inside the modal shell.]
"One of the most useful tools for composition is the children prop. Every component automatically receives props.children, which represents whatever JSX is placed between the opening and closing tags when the component is used.
This lets you build container or wrapper components that don't need to know in advance what they'll contain. A Card component provides a styled box with a shadow and border radius. It doesn't care what goes inside it — it just renders whatever children it receives. A Modal component provides the overlay, the centered panel, the close button — but its actual content is whatever you pass as children. This makes these container components incredibly flexible and reusable.
[Slide 49: "Composing Components Together — A Full Example" — A code example showing three or four components that work together: a PageLayout that accepts children, a ProfileHeader that uses an Avatar component, and a full page assembled from all of them. Show the final rendered structure alongside the code.]
"Here's what composition looks like in practice. We have a PageLayout that provides consistent structure for any page. We have a ProfileHeader that handles the header area, which uses a smaller Avatar component. Each piece is focused on its own concern. When we assemble the page, we're just combining these pieces — like LEGOs clicking together. When you need to change the avatar style, you change the Avatar component and every place it's used updates automatically."

CLOSING (4 minutes)
[Slide 50: "What We Covered Today" — A visual map of all 9 topic areas arranged as a connected diagram showing how they relate to each other — React Philosophy → SPAs → Virtual DOM → JSX → Components → Props → Lists/Keys → Conditional Rendering → Composition. Use arrows to show the conceptual flow between topics.]
"Let's bring today together. We started with the philosophy — why React exists, what problems it was designed to solve, and the three core ideas that run through everything: declarative UI, component-based architecture, and unidirectional data flow. From there we understood SPAs — the kind of application model React is built for.
We went deep on the Virtual DOM and reconciliation — understanding that React is doing sophisticated work to update the real DOM as efficiently as possible, and that keys are how you help React do that work correctly for lists.
We covered JSX thoroughly — not just the syntax, but why it exists and all the rules that trip people up. We distinguished functional from class components and established clearly that functional components are what you should write. We built functional components, passed data through props, rendered dynamic lists with keys, implemented conditional rendering using three different patterns, and composed components together.
[Slide 51: "The 5 Principles to Carry Forward" — Five items, each with a brief explanation: 1) "React is declarative — describe the desired UI, not the steps to get there." 2) "Data flows one direction — from parent to child via props." 3) "Props are read-only — a component never modifies its own inputs." 4) "Keys are essential on lists — use stable, data-derived values, never array indexes on dynamic lists." 5) "Build small, composable components — one component, one responsibility."]
"If you remember nothing else from today, remember these five principles. They're not just React rules — they're the thinking that will make you a better React developer.
In our next session, we'll tackle state — which is how components manage data that changes over time. Everything you learned today about props and components is the exact foundation you need for that. Please practice before next class: write a few components from scratch, pass props between them, render a list from an array with proper keys, and try each of the three conditional rendering patterns. Typing it out yourself is the only way to make this stick. See you next time."

---

## INSTRUCTOR NOTES

**Missing:** The closing script does a good job teasing state — but a brief one-slide forward reference explaining *that* hooks exist and *why* they matter would reduce the cliffhanger. After covering the Virtual DOM and props, students will be asking "but how does the UI actually change?" A single teaser slide makes the transition to Hooks Part 1 feel intentional rather than abrupt.

**Unnecessary/Too Advanced:** Nothing to remove. The content is well-scoped and well-sequenced.

**Density:** The Virtual DOM and reconciliation section is thorough at roughly 6 slides — this is appropriate given how foundational that mental model is for understanding React's performance model. The keys-in-lists section is important and the warning about using array index as a key is an excellent inclusion — give it enough time for the gotcha to land clearly.