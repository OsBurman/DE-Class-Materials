#!/bin/bash
# Exercise 11 — Elastic Beanstalk: SOLUTION

# ============================================================
# PART 1 — Beanstalk Concepts
# ============================================================

# 1. Application vs Environment vs Application Version:
#    Application: top-level logical container — a named group of environments and versions.
#    Environment: a running deployment (EC2, ASG, ELB, alarms). Multiple environments
#      per application (dev, staging, prod).
#    Application Version: a labeled, versioned deployable artifact (JAR/ZIP) stored in S3.
#      You can deploy any version to any environment and roll back by deploying an older one.

# 2. Deployment policies:
#    All at once: Updates ALL instances simultaneously. Fastest, causes downtime. Dev/test only.
#    Rolling: Updates instances in batches. Reduces capacity temporarily, no downtime.
#    Rolling with additional batch: Like rolling but first launches extra instances so
#      capacity never drops. Slightly more expensive.
#    Immutable: Launches a new ASG with the new version. Health checks pass → swap.
#      Failure → discard new ASG. Zero downtime, instant rollback. Best for production.
#    Blue/Green: Deploy to a separate environment, test, then swap environment URLs via
#      CNAME. Full rollback by reverting DNS. Maximum control, highest cost during cutover.

# 3. Immutable vs Rolling:
#    Immutable: production deploys where zero downtime and instant rollback are required.
#      Original instances are untouched throughout — new ASG is discarded on failure.
#    Rolling: cost-sensitive environments where brief capacity reduction is acceptable
#      (e.g., dev/staging during low-traffic windows).

# ============================================================
# PART 2 — Deploy Spring Boot App
# ============================================================

# Prerequisites: pip install awsebcli

# a. Initialize Beanstalk application
eb init order-service-app \
  --platform "java-21" \
  --region us-east-1

# Create Procfile to tell Beanstalk how to start the JAR
echo 'web: java -jar order-service-1.0.jar' > Procfile

# b. Create single-instance environment (no ELB, cheaper for this exercise)
eb create order-service-prod \
  --single \
  --instance-type t3.small \
  --envvars APP_VERSION=1.0,SPRING_PROFILES_ACTIVE=prod

# c. Deploy
eb deploy

# d. Open in browser
eb open

# e. Check health and list events
eb health     # overall environment color + instance health
eb events     # recent deployment/scaling/alert events

# f. Update environment variable and re-deploy
eb setenv APP_VERSION=2.0
eb deploy

# g. Terminate environment (destroys all AWS resources — avoids charges)
eb terminate order-service-prod --force

# ============================================================
# PART 3 — .ebextensions configuration
# ============================================================

mkdir -p .ebextensions
cat > .ebextensions/env-config.config << 'EOF'
option_settings:
  aws:elasticbeanstalk:application:environment:
    JAVA_TOOL_OPTIONS: "-Xmx512m -Xms256m"

  aws:elasticbeanstalk:environment:process:default:
    HealthCheckPath: /actuator/health
    MatcherHTTPCode: "200"
EOF

# ============================================================
# PART 4 — Reflection Answers
# ============================================================

# 1. What Beanstalk automates vs raw EC2:
#    EC2 alone requires: instance creation, security groups, AMI selection, ASG + launch
#    template, ELB + target group, health check config, CloudWatch alarms, S3 artifact
#    bucket, deployment scripts (stop/start app), log rotation. Beanstalk handles all of
#    this automatically via managed environments. You push code; it handles the rest.

# 2. When choose Beanstalk over ECS/EKS:
#    Beanstalk: fast setup, no Docker or Kubernetes knowledge required, standard web apps
#    (Spring Boot, Node.js, Django), small teams, PaaS simplicity with retained AWS access.
#    ECS/Fargate: when you need immutable container deployments, Docker-native workflows,
#    or tighter control over networking. EKS: when you need Kubernetes portability/tooling.

# 3. .elasticbeanstalk/config.yml:
#    Auto-generated by `eb init`. Stores CLI config: app name, environment, region, platform.
#    Does NOT contain secrets. Should be committed to version control so all team members
#    and CI/CD pipelines use the same app/environment/region without re-running eb init.

# 4. Memory leak — app crashes every 6h:
#    Beanstalk behavior: EC2 health check fails → ASG marks instance unhealthy → terminates
#    it → launches a replacement → Beanstalk deploys the current app version to it.
#    ALB stops routing to the crashed instance before it's terminated. Minimal user impact.
#    Investigation: `eb logs` (pull app and web server logs from all instances),
#    CloudWatch Logs (/aws/elasticbeanstalk/...), CloudWatch Metrics (MemoryUtilization
#    over time via CloudWatch Agent), heap profiler (VisualVM/JProfiler) with a load test,
#    heap dump with `jmap -dump:format=b,file=heap.hprof <pid>` via SSH into the instance.
